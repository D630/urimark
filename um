#!/usr/bin/env bash

# Copyright 2014f. D630
# https://github.com/D630/urimark

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace
#exec 2>> ~/um.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__um_version() { echo "v0.4.0.0" ; }

__um_usage()
{
    printf 'um (-a|-c|-d|-e|-h|-i|-m|-v) [<OPT>...]
um [<OPT>...] [<HOOK>]'
}

__um_help()
{
    printf "urimark $(__um_version)

$(__um_usage)

Subcommands:
  -a, --add                 Add a record
  -c, --compact, --com      Compact database
  -d, --delete, --del       Delete a record
  -e, --edit                Edit manually one record with EDITOR
  -h, --help                Show this instruction
  -i, --initialize, --init  Initialize database
  -m, --modify, --modi      Modify many records without EDITOR
  -v, --version             Print version

Options:
  Miscellaneous:
    -n, --non-interactive, --nv

  Operators:
    -!, --not
    -A, --and
    -M, --mod
    -O, --or

  Filters:
    -1, --id=ID
    -2, --ctime=CT, --ct=CT
    -3, --mtime=MT, --mt=MT
    -4, --tag=TAG
    -D, --description=DESC, --desc=DESC
    -N, --name=NAME
    -P, --part=PART
    -S, --scheme=SCHEME
    -U, --uri=URI
    -Y, --authority=AUTH, --auth=AUTH

  Special mod-Assignments:
    -5, --tag+=TAG
    -6, --tag-=TAG

You may use all long subcommands and options without double hypen.

Arguments:
  AUTH*                     'string'
  CT                        's' or range 's;s'. Two special
                            values: 'first' and 'last'
  DESC*                     'string'
  HOOK                      'string' without space character
  ID                        'int', 'int;int;n' or range 'int-int'
                            (or combi). Two special values: 'first'
                            and 'last'
  MT                        's' or range 's;s'. Two special
                            values: 'first' and 'last'
  NAME*                     'string'
  PART*                     'string'
  SCHEME*                   'http','https','ftp','ftps','dav','davs',
                            'gopher','webdav','webdavs'
  TAG*                      'string' or 'string;string;n'
  URI*                      'string'

* You may prefix these arguments with 'g~', 'l~' or 'r~' to use the
  core functions glob(), like() or regexp() (PCRE) of sqlite3.
"
}

__um_query ()
{
    declare \
        ct_single= \
        i= \
        id= \
        id_create_tbl_tmp= \
        id_operator= \
        id_single= \
        mt_single= \
        operator= \
        pattern= \
        sql_select= \
        var=

    declare -a \
        and=() \
        ids_range=() \
        ids_singles=() \
        not=() \
        or=() \
        or_and=() \
        query=() \
        result=() \
        times=()

    declare -A operators

    function __um_query_do
    {
        sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<SQLITE
.bail on
.echo off
.header off
.separator \"|\"
.mode list
.log "${URIMARK_DATA_DIR}/urimark.log"
.output "${URIMARK_DATA_DIR}/urimark.log"
.load "${URIMARK_CONF_FILE%/*}/pcre.so"
PRAGMA automatic_index = "1";
PRAGMA checkpoint_fullfsync = "0";
PRAGMA journal_mode = "MEMORY";
PRAGMA journal_size_limit = "-1";
PRAGMA synchronous = "0";
PRAGMA foreign_keys = "1";
PRAGMA locking_mode = "NORMAL";
PRAGMA max_page_count = "1073741823";
PRAGMA page_size = "32767";
PRAGMA recursive_triggers = "0";
PRAGMA secure_delete = "1";
PRAGMA temp_store = "2";
PRAGMA wal_autocheckpoint = "1000";
PRAGMA user_version = "0";
.output stdout
BEGIN TRANSACTION;
${query[*]}
${or[*]}
${and[*]}
${or_and[*]}
${not[*]}
${result[*]}
${sql_select}
COMMIT;
.quit
SQLITE
    }

    function __um_query_check_fn
    case $1 in
        g~?*)
            pattern="glob('${pattern#g~*}',${2})"
            ;;
        l~?*)
            pattern="like('${pattern#l~*}',${2})"
            ;;
        r~?*)
            pattern="regexp('${pattern#r~*}',${2})"
            ;;
        s~?*)
            pattern="${pattern#s~*}'"
            ;;
        *)
            pattern="${2} == '${pattern}'"
    esac

    if (($# == 0))
    then
        sql_select="SELECT * FROM view_csv_quoted;"
    else
        for i
        do
            read -r var pattern <<< "${i/=/ }"
            case $var in
                and)
                    operator=and
                    ;;
                not)
                    operator=not
                    ;;
                or)
                    operator=or
                    ;;
                *)
                    operator=${operator:-or}
                    operators[$operator]=$((${operators[$operator]} + 1))
                    case $var in
                        id)
                            id_operator=$operator
                            id_create_tbl_tmp="CREATE TEMP TABLE [${id_operator}${operators[$operator]}] AS"
                            for id in ${pattern//,/ }
                            do
                                if [[ $id =~ - ]]
                                then
                                    for id in ${id//-/ }
                                    do
                                        ids_range+=("$id")
                                    done
                                    if [[ $id_create_tbl_tmp ]]
                                    then
                                        query+=("${id_create_tbl_tmp}
                                            SELECT VC.* FROM view_csv AS VC
                                            INNER JOIN view_calc_id_first AS IF
                                            INNER JOIN view_calc_id_last AS IL
                                            ON
                                                VC.id >= ${ids_range[0]//first/IF.id_first} AND
                                                VC.id <= ${ids_range[1]//last/IL.id_last}
                                            ORDER BY VC.id ASC;")
                                        id_create_tbl_tmp=
                                    else
                                        query+=("INSERT INTO [${id_operator}${operators[$operator]}]
                                            SELECT VC.* FROM view_csv AS VC
                                            INNER JOIN view_calc_id_first AS IF
                                            INNER JOIN view_calc_id_last AS IL
                                            ON
                                                VC.id >= ${ids_range[0]//first/IF.id_first} AND
                                                VC.id <= ${ids_range[1]//last/IL.id_last}
                                            ORDER BY VC.id ASC;")
                                    fi
                                    unset -v ids_range
                                else
                                    ids_singles+=("$id")
                                fi
                            done
                            ((${#ids_singles[@]} != 0)) && {
                                if [[ $id_create_tbl_tmp ]]
                                then
                                    query+=("$id_create_tbl_tmp")
                                else
                                    query+=("INSERT INTO [${id_operator}${operators[$operator]}]")
                                fi
                                printf -v pattern '%s,' "${ids_singles[@]}"
                                if [[ $pattern =~ [^0-9,] ]]
                                then
                                    if [[ $pattern =~ first && $pattern =~ last ]]
                                    then
                                        pattern=${pattern//first/\'first\'}
                                        pattern=${pattern//last/\'last\'}
                                        id_single="VC.id IN (${pattern%,}) OR VC.id == F.id_first OR VC.id == L.id_last"
                                    elif [[ $pattern =~ first ]]
                                    then
                                        pattern=${pattern//first/\'first\'}
                                        id_single="VC.id IN (${pattern%,}) OR VC.id == F.id_first"
                                    elif [[ $pattern =~ last ]]
                                    then
                                        pattern=${pattern//last/\'last\'}
                                        id_single="VC.id IN (${pattern%,}) OR VC.id == L.id_last"
                                    fi
                                    query+=("SELECT VC.* FROM view_csv AS VC
                                        INNER JOIN view_calc_id_first AS F
                                        INNER JOIN view_calc_id_last AS L
                                        ON
                                            ${id_single}
                                        ORDER BY VC.id ASC;")
                                else
                                    query+=("SELECT * FROM view_csv WHERE id IN (${pattern%,}) ORDER BY id ASC;")
                                fi
                            }
                            ;;
                        ct)
                            for pattern in ${pattern//,/ }
                            do
                                times+=("$pattern")
                            done
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS")
                            if ((${#times[@]} == 1))
                            then
                                if [[ ${times[0]} == first ]]
                                then
                                    ct_single="VC.ctime == A.ctime_asc"
                                elif [[ ${times[0]} == last ]]
                                then
                                    ct_single="VC.ctime == D.ctime_desc"
                                else
                                    ct_single="VC.ctime == ${times[0]}"
                                fi
                                query+=("SELECT VC.* FROM view_csv AS VC
                                    INNER JOIN view_calc_ctime_asc A
                                    INNER JOIN view_calc_ctime_desc AS D
                                    ON
                                        ${ct_single}
                                    ORDER BY VC.id ASC;")
                            elif ((${#times[@]} == 2))
                            then
                                query+=("SELECT VC.* FROM view_csv AS VC
                                    INNER JOIN view_calc_ctime_asc A
                                    INNER JOIN view_calc_ctime_desc AS D
                                    ON
                                        VC.ctime >= ${times[0]//first/A.ctime_asc} AND
                                        VC.ctime <= ${times[1]//last/D.ctime_desc}
                                    ORDER BY VC.id ASC;")
                            fi
                            ;;
                        mt)
                            for pattern in ${pattern//,/ }
                            do
                                times+=("$pattern")
                            done
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS")
                            if ((${#times[@]} == 1))
                            then
                                if [[ ${times[0]} == first ]]
                                then
                                    mt_single="VC.mtime == A.mtime_asc"
                                elif [[ ${times[0]} == last ]]
                                then
                                    mt_single="VC.mtime == D.mtime_desc"
                                else
                                    mt_single="VC.mtime == ${times[0]}"
                                fi
                                query+=("SELECT VC.* FROM view_csv AS VC
                                    INNER JOIN view_calc_mtime_asc A
                                    INNER JOIN view_calc_mtime_desc AS D
                                    ON
                                        ${mt_single}
                                    ORDER BY VC.id ASC;")
                            elif ((${#times[@]} == 2))
                            then
                                query+=("SELECT VC.* FROM view_csv AS VC
                                    INNER JOIN view_calc_mtime_asc A
                                    INNER JOIN view_calc_mtime_desc AS D
                                    ON
                                        VC.mtime >= ${times[0]//first/A.mtime_asc} AND
                                        VC.mtime <= ${times[1]//last/D.mtime_desc}
                                    ORDER BY VC.id ASC;")
                            fi
                            ;;
                        scheme)
                            __um_query_check_fn "$pattern" "scheme"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS SELECT * FROM view_csv WHERE ${pattern} ORDER BY id;")
                            ;;
                        authority)
                            __um_query_check_fn "$pattern" "auth"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS SELECT * FROM view_csv WHERE ${pattern} ORDER BY id;")
                            ;;
                        part)
                            __um_query_check_fn "$pattern" "part"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS SELECT * FROM view_csv WHERE ${pattern} ORDER BY id;")
                            ;;
                        name)
                            __um_query_check_fn "$pattern" "name"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS SELECT * FROM view_csv WHERE ${pattern} ORDER BY id;")
                            ;;
                        description)
                            __um_query_check_fn "$pattern" "desc"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS SELECT * FROM view_csv WHERE ${pattern} ORDER BY id;")
                            ;;
                        tag)
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS")
                            for pattern in ${pattern//,/ }
                            do
                                __um_query_check_fn "$pattern" "T.tag"
                                query+=("SELECT CV.* FROM view_csv AS CV INNER JOIN tbl_tags AS T INNER JOIN tbl_tags_urimark AS U ON ${pattern} AND U.tbl_tags_key == T.key AND CV.id == U.tbl_urimark_id UNION")
                            done
                            query[-1]=${query[-1]/ UNION/;}
                            ;;
                        reference)
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS")
                            for pattern in ${pattern//,/ }
                            do
                                __um_query_check_fn "$pattern" "R.ref"
                                query+=("SELECT CV.* FROM view_csv AS CV INNER JOIN tbl_references AS R INNER JOIN tbl_references_urimark AS U ON ${pattern} AND U.tbl_references_key == R.key AND CV.id == U.tbl_urimark_id UNION")
                            done
                            query[-1]=${query[-1]/ UNION/;}
                            ;;
                        uri)
                            __um_query_check_fn "$pattern" "U.uri"
                            query+=("CREATE TEMP TABLE [${operator}${operators[$operator]}] AS
                                    SELECT CV.*
                                    FROM view_csv AS CV
                                    INNER JOIN view_id_uri As U
                                    ON
                                        ${pattern} AND
                                        U.id == CV.id
                                    ORDER BY CV.id;")
                    esac
                        ids_singles=()
                        times=()
            esac
        done

        if [[ ${operators[or]} ]]
        then
            or+=("CREATE TEMP TABLE [or0] AS")
            for ((i=1 ; i <= ${operators[or]} ; ++i))
            do
                or+=("SELECT * FROM [or${i}] UNION")
            done
            or[-1]=${or[-1]/ UNION/ORDER BY id;}
        else
            or+=("CREATE TEMP TABLE [or0] AS SELECT * FROM view_csv WHERE id == 0;")
        fi

        if [[ ${operators[and]} -gt 1 ]]
        then
            and+=("CREATE TEMP TABLE [and0] AS SELECT * FROM (")
            for ((i=1 ; i <= ${operators[and]}; ++i))
            do
                and+=("SELECT * FROM [and${i}] UNION ALL")
            done
            and[-1]=${and[-1]/ UNION ALL/) GROUP BY id HAVING (COUNT(id) > 1);}
            or_and=("CREATE TEMP TABLE [or_and] AS SELECT * FROM (SELECT * FROM [or0] UNION ALL SELECT * FROM [and0]) GROUP BY id HAVING (COUNT(id) > 1);")
        elif [[ ${operators[and]} -eq 1 ]]
        then
            or_and=("CREATE TEMP TABLE [or_and] AS SELECT * FROM (SELECT * FROM [or0] UNION ALL SELECT * FROM [and1]) GROUP BY id HAVING (COUNT(id) > 1);")
        else
            or_and=("ALTER TABLE [or0] RENAME TO [or_and];")
        fi

        if [[ ${operators[not]} ]]
        then
            not+=("CREATE TEMP TABLE [not0] AS")
            for ((i=1 ; i <= ${operators[not]} ; ++i))
            do
                not+=("SELECT * FROM [not${i}] UNION")
            done
            not[-1]=${not[-1]/ UNION/ORDER BY id;}
            result=("CREATE TEMP TABLE [result] AS SELECT * FROM [or_and] WHERE id NOT IN (SELECT id FROM [not0]);")
        else
            result=("ALTER TABLE [or_and] RENAME TO [result];")
        fi

        sql_select="SELECT '\"' || id, ctime, mtime, scheme, auth, part, name, desc, tags, refs || '\"' FROM [result];"
    fi

    [[ ${hook[${_um_options[hook_chosen]} header]} ]] && eval "${hook[${_um_options[hook_chosen]} header]}"
    eval "${hook[${_um_options[hook_chosen]} preprocess]} __um_query_do ${hook[${_um_options[hook_chosen]} postprocess]}"
    [[ ${hook[${_um_options[hook_chosen]} footer]} ]] && eval "${hook[${_um_options[hook_chosen]} footer]}" || :
}

__um_add ()
{
    declare \
        authority= \
        description= \
        i= \
        name= \
        part= \
        scheme= \
        uri= \
        id=

    declare -a \
        tags=() \
        references=()

    function __um_add_record
    {
        declare \
            insert_tbl_tags= \
            insert_tbl_references_urimark= \
            insert_tbl_tags_urimark= \
            insert_tbl_urimark_name= \
            insert_tbl_urimark_description= \
            insert_tbl_names= \
            insert_tbl_descriptions= \
            delete_tbl_urimark=

        if [[ -z $id || $id =~ [^0-9] ]]
        then
            read -r id < "${URIMARK_DATA_DIR}/next.id"
        else
            delete_tbl_urimark="DELETE FROM tbl_urimark WHERE id = '${id}';"
        fi

        ((${#tags[@]} == 0)) && tags+=(${_um_options[tag_default]:-})
        [[ ${tags[@]} ]] && {
            printf -v insert_tbl_tags "INSERT OR IGNORE INTO tbl_tags (tag) VALUES ('%s\n" "${tags[@]/%/\');}"
            printf -v insert_tbl_tags_urimark "INSERT OR IGNORE INTO tbl_tags_urimark (tbl_urimark_id, tbl_tags_key) VALUES ('${id}', (SELECT key FROM tbl_tags WHERE tag = '%s\n" "${tags[@]/%/\'));}"
        }

        ((${#references[@]} == 0)) && references+=(${_um_options[reference_default]:-})
        [[ ${references[@]} ]] && {
            printf -v insert_tbl_references_urimark "INSERT OR IGNORE INTO tbl_references_urimark (tbl_urimark_id, tbl_references_key) VALUES ('${id}', (SELECT key FROM tbl_references WHERE ref = '%s\n" "${references[@]/%/\'));}"
        }

        [[ ${name:-${_um_options[name_default]}} ]] && {
            insert_tbl_names="INSERT OR IGNORE INTO tbl_names (name) VALUES ('${name:-${_um_options[name_default]}}');"
            insert_tbl_urimark_name=",(SELECT key FROM tbl_names WHERE name = '${name:-${_um_options[name_default]}}')"
        }

        [[ ${description:-${_um_options[description_default]}} ]] && {
            insert_tbl_descriptions="INSERT OR IGNORE INTO tbl_descriptions (desc) VALUES ('${description:-${_um_options[description_default]}}');"
            insert_tbl_urimark_description=",(SELECT key FROM tbl_descriptions WHERE desc = '${description:-${_um_options[description_default]}}')"
        }

        sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output "${URIMARK_DATA_DIR}/urimark.log"
PRAGMA automatic_index = "1";
PRAGMA checkpoint_fullfsync = "0";
PRAGMA journal_mode = "MEMORY";
PRAGMA journal_size_limit = "-1";
PRAGMA synchronous = "0";
PRAGMA foreign_keys = "1";
PRAGMA locking_mode = "NORMAL";
PRAGMA max_page_count = "1073741823";
PRAGMA page_size = "32767";
PRAGMA recursive_triggers = "0";
PRAGMA secure_delete = "1";
PRAGMA temp_store = "2";
PRAGMA wal_autocheckpoint = "1000";
PRAGMA user_version = "0";
.output stdout

BEGIN TRANSACTION;

${delete_tbl_urimark}

INSERT OR IGNORE INTO tbl_authorities (auth) VALUES ('${authority}');
INSERT OR IGNORE INTO tbl_parts (part) VALUES ('${part}');
${insert_tbl_names}
${insert_tbl_descriptions}

INSERT OR IGNORE INTO tbl_urimark (id, tbl_schemes_key, tbl_authorities_key, tbl_parts_key ${insert_tbl_names:+, tbl_names_key} ${insert_tbl_descriptions:+, tbl_descriptions_key})
VALUES
    (
        '${id}',
        (SELECT key FROM tbl_schemes WHERE scheme = '${scheme}'),
        (SELECT key FROM tbl_authorities WHERE auth = '${authority}'),
        (SELECT key FROM tbl_parts WHERE part = '${part}')
        ${insert_tbl_urimark_name}
        ${insert_tbl_urimark_description}
    );

${insert_tbl_references_urimark}
${insert_tbl_tags}
${insert_tbl_tags_urimark}

END TRANSACTION;

.output "${URIMARK_DATA_DIR}/next.id"
SELECT id_next FROM view_calc_id_next;

.quit
SQLITE
    }

    function __um_add_parse_uri
    {
        uri=${uri%*/}
        scheme=${uri%%:*}
        [[ $scheme =~ ^(https?|ftps?|davs?|gopher|webdavs?)$ ]] || { echo "Error: Wrong scheme" 1>&2 ; exit 1 ; }
        IFS='/' read -r authority part <<< "${uri##*://}"
        [[ $authority =~ ^.*\.[^0-9]*$ ]] || { echo "Error: Malformed uri" 1>&2 ; exit 1 ; }
        part=/${part%%/}
    }

    if (($# == 0))
    then
        read -re -p "URI: " uri
        __um_add_parse_uri
        read -re -p "Id:" -i "next" id
        read -re -p "Name: " name
        read -re -p "Description: " description
        IFS=',' read -re -p "Tags: " -a tags
        IFS=',' read -re -p "References: " -a references
    else
        for i
        do
            case $i in
                uri=?*)
                    uri=${i/uri=/}
                    __um_add_parse_uri
                    ;;
                name=?*)
                    name=${i/name=/}
                    ;;
                description=?*)
                    description=${i/description=/}
                    ;;
                tag=?*)
                    IFS=',' read -r -a tags <<< "${i/tag=/}"
                    ;;
                reference=?*)
                    IFS=',' read -r -a references <<< "${i/reference=/}"
                    ;;
                where)
                    continue
                    ;;
                id=?*)
                    id=${i/id=/}
            esac
        done
    fi

    if __um_add_record
    then
        { printf '%s\n' "Add id ${id} ${uri%*/}" 1>&2 ; exit 0 ; }
    else
        exit 1
    fi
}

__um_delete ()
{
    declare \
        delete_all= \
        response= \
        uri=

    declare -i id=

    declare -a deletion=()

    exec 3<&0

    if (($# == 0))
    then
        { echo "Error: No filter specified" 1>&2 ; exit 1 ; }
    else
        while read -r id uri
        do
            if [[ $delete_all == delete_all || ${_um_options[non_interactive]} == non_interactive ]]
            then
                deletion+=("DELETE FROM tbl_urimark WHERE id = '${id}';${id}")
            else
                printf 'ID    => %s\nURI   => %s\n' "$id" "$uri"
                read -u 3 -p "Do you really wanne delete this record? (y/n/all/selected/quit) " response
                case $response in
                    a|all)
                        delete_all=delete_all
                        ;&
                    y|yes)
                        deletion+=("DELETE FROM tbl_urimark WHERE id = '${id}';${id}")
                        ;;
                    s|selected)
                        break
                        ;;
                    q|quit)
                        deletion=()
                        { echo "Quit deleting" 1>&2 ; exit 0 ; }
                        ;;
                    *)
                        continue
                esac
            fi
        done < <(_um_options[hook_chosen]=um_default1 ; __um_query "$@")
        exec 3<&-
        if ((${#deletion[@]} == 0))
        then
            { echo "Error: No uri has been deleted" 1>&2 ; exit 1 ; }
        else
            printf '%s\n' "${deletion[@]/*;/Delete id }" 1>&2
            printf -v deletion '%s' "${deletion[@]/;*/;}"
            sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output "${URIMARK_DATA_DIR}/urimark.log"
PRAGMA automatic_index = "1";
PRAGMA checkpoint_fullfsync = "0";
PRAGMA journal_mode = "MEMORY";
PRAGMA journal_size_limit = "-1";
PRAGMA synchronous = "0";
PRAGMA locking_mode = "NORMAL";
PRAGMA max_page_count = "1073741823";
PRAGMA page_size = "32767";
PRAGMA recursive_triggers = "0";
PRAGMA secure_delete = "1";
PRAGMA temp_store = "2";
PRAGMA wal_autocheckpoint = "1000";
PRAGMA user_version = "0";
.output stderr

BEGIN TRANSACTION;
${deletion}
COMMIT;

.output "${URIMARK_DATA_DIR}/next.id"
SELECT id_next FROM view_calc_id_next;

.quit
SQLITE
        fi
    fi
}

__um_edit ()
{
    declare \
        db_authority= \
        db_ctime= \
        db_description= \
        db_id= \
        db_mtime= \
        db_name= \
        db_part= \
        db_references
        db_scheme= \
        db_tags= \
        delete_tbl_references_urimark= \
        delete_tbl_tags_urimark= \
        editor=${_um_options[editor]} \
        file_tmp= \
        insert_tbl_descriptions= \
        insert_tbl_names= \
        insert_tbl_tags= \
        insert_tbl_tags_urimark= \
        md5_post= \
        md5_pre= \
        val= \
        var=

    declare -a \
        references=() \
        tags=() \
        update_tbl_urimark=()

    if (($# == 0))
    then
        { echo "Error: No filter specified" 1>&2 ; exit 1 ; }
    else
        mkdir -p -- "$URIMARK_TMP_DIR"
        while IFS='|' read -r db_id db_ctime db_mtime db_scheme db_authority db_part db_name db_description db_tags db_references
        do
            file_tmp=${URIMARK_TMP_DIR}/urimark.${RANDOM}
            printf '%s\n' "## * Editable are: name, description, tags and references
## * Do not forget to separate tags and references with semicolon
## * After modification this file will be read with the help of 'eval'.
##   So you may use expansions and substitions.

ID          ${db_id}
CTIME       ${db_ctime}
MTIME       ${db_mtime}
SCHEME      ${db_scheme}
AUTHORITY   ${db_authority}
PART        ${db_part}
NAME        ${db_name}
DESCRIPTION ${db_description}
TAGS        ${db_tags}
REFS        ${db_references}" > "$file_tmp"
            md5_pre=$(md5sum "$file_tmp")
            $editor "$file_tmp" </dev/tty
            md5_post=$(md5sum "$file_tmp")
            if [[ $md5_pre != $md5_post ]]
            then
                update_tbl_urimark=("UPDATE tbl_urimark SET")
                while read -r var val
                do
                    [[ $val ]] && {
                        case ${var,,} in
                            tags)
                                [[ $val != $db_tags ]] && {
                                    eval "val=$val"
                                    delete_tbl_tags_urimark="DELETE FROM tbl_tags_urimark WHERE tbl_urimark_id = '${db_id//\"/}';"
                                    mapfile -t tags < <(printf '%s\n' "${val//\;/$'\n'}")
                                    printf -v insert_tbl_tags "INSERT OR IGNORE INTO tbl_tags (tag) VALUES ('%s\n" "${tags[@]/%/\');}"
                                    printf -v insert_tbl_tags_urimark "INSERT OR IGNORE INTO tbl_tags_urimark (tbl_urimark_id, tbl_tags_key) VALUES ('${db_id//\"/}',(SELECT key FROM tbl_tags WHERE tag = '%s\n" "${tags[@]/%/\'));}"
                                }
                                ;;
                            refs)
                                [[ $val != $db_references ]] && {
                                    eval "val=$val"
                                    delete_tbl_references_urimark="DELETE FROM tbl_references_urimark WHERE tbl_urimark_id = '${db_id//\"/}';"
                                    mapfile -t references < <(printf '%s\n' "${val//\;/$'\n'}")
                                    printf -v insert_tbl_references_urimark "INSERT OR IGNORE INTO tbl_references_urimark (tbl_urimark_id, tbl_references_key) VALUES ('${db_id//\"/}',(SELECT key FROM tbl_references WHERE ref = '%s\n" "${references[@]/%/\'));}"
                                }
                                ;;
                            name)
                                [[ $val != $db_name ]] && {
                                    eval "val=$val"
                                    insert_tbl_names="INSERT OR IGNORE INTO tbl_names (name) VALUES ('${val}');"
                                    update_tbl_urimark+=("tbl_names_key = (SELECT key FROM tbl_names WHERE name = '${val}'),")
                                }
                                ;;
                            description)
                                [[ $val != $db_description ]] && {
                                    eval "val=$val"
                                    insert_tbl_descriptions="INSERT OR IGNORE INTO tbl_descriptions (desc) VALUES ('${val}');"
                                    update_tbl_urimark+=("tbl_descriptions_key = (SELECT key FROM tbl_descriptions WHERE desc = '${val}'),")
                                }
                                ;;
                            *)
                                continue
                        esac
                    }
                    unset -v var val
                done < "$file_tmp"
                if ((${#update_tbl_urimark[@]} > 1))
                then
                    update_tbl_urimark[-1]=${update_tbl_urimark[-1]%,}
                    update_tbl_urimark+=("WHERE id = '${db_id//\"/}';")
                else
                    unset -v update_tbl_urimark
                fi
                printf '%s\n' "Edit id ${db_id//\"/}" 1>&2
                sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output "${URIMARK_DATA_DIR}/urimark.log"
PRAGMA automatic_index = "1";
PRAGMA checkpoint_fullfsync = "0";
PRAGMA journal_mode = "MEMORY";
PRAGMA journal_size_limit = "-1";
PRAGMA synchronous = "0";
PRAGMA locking_mode = "NORMAL";
PRAGMA max_page_count = "1073741823";
PRAGMA page_size = "32767";
PRAGMA recursive_triggers = "0";
PRAGMA secure_delete = "1";
PRAGMA temp_store = "2";
PRAGMA wal_autocheckpoint = "1000";
PRAGMA user_version = "0";
.output stdout

BEGIN TRANSACTION;
${insert_tbl_names}
${insert_tbl_descriptions}
${update_tbl_urimark[*]}
${delete_tbl_tags_urimark}
${insert_tbl_tags}
${insert_tbl_tags_urimark}

${delete_tbl_references_urimark}
${insert_tbl_references_urimark}
COMMIT;

.quit
SQLITE
            else
                echo "Error: Record ${db_id//\"/} has not been modified" 1>&2
            fi
        done < <(_um_options[hook_chosen]=um_default2 ; __um_query "$@")
        rm -fr -- "$URIMARK_TMP_DIR" 2>/dev/null
    fi
}

__um_modify ()
{
    declare \
        description= \
        i= \
        modify_all= \
        name= \
        r= \
        re= \
        re_m= \
        re_p= \
        response= \
        t= \
        ta= \
        ta_m= \
        ta_p= \
        uri=

    declare -i id=

    declare -a \
       modification=() \
       references=() \
       references_m=() \
       references_p=() \
       tags=() \
       tags_m=() \
       tags_p=()

    exec 3<&0

    for i in "${!_um_assignments[@]}"
    do
        case ${_um_assignments[$i]} in
            name=?*)
                name=${_um_assignments[$i]#*=}
                ;;
            description=?*)
                description=${_um_assignments[$i]#*=}
                ;;
            tag=?*)
                t=${_um_assignments[$i]#*=}
                printf -v ta '%s\n' "${t//\,/$'\n'}"
                tags+=($ta)
                ;;
            tag+=?*)
                t_p[$i]=${_um_assignments[$i]#*+=}
                printf -v ta_p '%s\n' "${t_p[$i]//\,/$'\n'}"
                tags_p+=($ta_p)
                ;;
            tag-=?*)
                t_m[$i]=${_um_assignments[$i]#*-=}
                printf -v ta_m '%s\n' "${t_m[$i]//\,/$'\n'}"
                tags_m+=($ta_m)
                ;;
            reference=?*)
                r=${_um_assignments[$i]#*=}
                printf -v re '%s\n' "${r//\,/$'\n'}" "ID"
                references+=($re)
                ;;
            reference+=?*)
                r_p=${_um_assignments[$i]#*=}
                printf -v re_p '%s\n' "${r_p//\,/$'\n'}"
                references_p+=($re_p)
                ;;
            reference-=?*)
                r_m[$i]=${_um_assignments[$i]#*-=}
                printf -v re_m '%s\n' "${r_m[$i]//\,/$'\n'}"
                references_m+=($re_m)
                ;;
            *)
                printf '%s\n' "Error: Malformed modificator: '${_um_assignments[$i]}'" 1>&2
                unset -v "_um_assignments[$i]"
        esac
    done

    function __um_modify_build_query
    {
        [[ $name ]] && {
            modification+=("INSERT OR IGNORE INTO tbl_names (name) VALUES ('$name');"
            "UPDATE tbl_urimark SET tbl_names_key = (SELECT key FROM tbl_names WHERE name = '$name') WHERE id = '${id}';")
        }

        [[ $description ]] && {
            modification+=("INSERT OR IGNORE INTO tbl_descriptions (desc) VALUES ('$description');"
            "UPDATE tbl_urimark SET tbl_descriptions_key = (SELECT key FROM tbl_descriptions WHERE desc = '$description') WHERE id = '${id}';")
        }

        ((${#tags[@]} > 0)) && {
            printf -v insert_tbl_tags "INSERT OR IGNORE INTO tbl_tags (tag) VALUES ('%s\n" "${tags[@]/%/\');}"
            printf -v insert_tbl_tags_urimark "INSERT OR IGNORE INTO tbl_tags_urimark (tbl_urimark_id, tbl_tags_key) VALUES ('${id}',(SELECT key FROM tbl_tags WHERE tag = '%s\n" "${tags[@]/%/\'));}"
            modification+=("$insert_tbl_tags"
                "DELETE FROM tbl_tags_urimark WHERE tbl_urimark_id = '${id}';"
                "$insert_tbl_tags_urimark")
        }

        ((${#tags_p[@]} > 0)) && {
            printf -v insert_tbl_tags "INSERT OR IGNORE INTO tbl_tags (tag) VALUES ('%s\n" "${tags_p[@]/%/\');}"
            printf -v insert_tbl_tags_urimark "INSERT OR IGNORE INTO tbl_tags_urimark (tbl_urimark_id, tbl_tags_key) VALUES ('${id}',(SELECT key FROM tbl_tags WHERE tag = '%s\n" "${tags_p[@]/%/\'));}"
            modification+=("$insert_tbl_tags" "$insert_tbl_tags_urimark")
        }

        ((${#tags_m[@]} > 0)) && {
            printf -v delete_tbl_tags_urimark "DELETE FROM tbl_tags_urimark WHERE tbl_urimark_id = '${id}' AND tbl_tags_key = (SELECT key FROM tbl_tags WHERE tag = '%s\n" "${tags_m[@]/%/\');}"
            modification+=("$delete_tbl_tags_urimark" "INSERT OR IGNORE INTO tbl_tags_urimark (tbl_urimark_id) VALUES ('${id}');")
        }

        ((${#references[@]} > 0)) && {
            references=("${references[@]//ID/${id}}")
            printf -v insert_tbl_references_urimark "INSERT OR IGNORE INTO tbl_references_urimark (tbl_urimark_id, tbl_references_key) VALUES ('${id}',(SELECT key FROM tbl_references WHERE ref = '%s\n" "${references[@]/%/\'));}"
            modification+=("DELETE FROM tbl_references_urimark WHERE tbl_urimark_id = '${id}';"
                "$insert_tbl_references_urimark")
        }

        ((${#references_p[@]} > 0)) && {
            printf -v insert_tbl_references_urimark "INSERT OR IGNORE INTO tbl_references_urimark (tbl_urimark_id, tbl_references_key) VALUES ('${id}',(SELECT key FROM tbl_references WHERE ref = '%s\n" "${references_p[@]/%/\'));}"
            modification+=("$insert_tbl_references_urimark")
        }

        ((${#references_m[@]} > 0)) && {
            printf -v delete_tbl_references_urimark "DELETE FROM tbl_references_urimark WHERE tbl_urimark_id = '${id}' AND tbl_references_key = (SELECT key FROM tbl_references WHERE ref = '%s\n" "${references_m[@]/%/\');}"
            modification+=("$delete_tbl_references_urimark" "INSERT OR IGNORE INTO tbl_references_urimark (tbl_urimark_id, tbl_references_key) VALUES ('${id}', (SELECT key FROM tbl_references WHERE ref = '${id}'));")
        }
    }

    if ((${#_um_assignments[@]} == 0))
    then
         { echo "Error: No assignments specified" 1>&2 ; exit 1 ; }
    else
        while read -r id uri
        do
            if [[ $modify_all == modify_all  || ${_um_options[non_interactive]} == non_interactive ]]
            then
                __um_modify_build_query
                printf '%s\n' "Modify id ${id}" 1>&2
            else
                printf 'ID    => %s\nURI   => %s\n' "$id" "$uri"
                read -u 3 -p "Do you really wanne modify this record? (y/n/all/selected/quit) " response
                case $response in
                    a|all)
                        modify_all=modify_all
                        ;&
                    y|yes)
                        __um_modify_build_query
                        printf '%s\n' "Modify id ${id}" 1>&2
                        ;;
                    s|selected)
                        break
                        ;;
                    q|quit)
                        modification=()
                        { echo "Quit modifying" 1>&2 ; exit 1 ; }
                        ;;
                    *)
                        continue
                esac
            fi
        done < <(_um_options[hook_chosen]=um_default1 ; __um_query "$@")
        exec 3<&-
        if ((${#modification[@]} == 0))
        then
            { echo "Error: No uri has been chosen" 1>&2 ; exit 1 ; }
        else
            sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output "${URIMARK_DATA_DIR}/urimark.log"
PRAGMA automatic_index = "1";
PRAGMA checkpoint_fullfsync = "0";
PRAGMA journal_mode = "MEMORY";
PRAGMA journal_size_limit = "-1";
PRAGMA synchronous = "0";
PRAGMA locking_mode = "NORMAL";
PRAGMA max_page_count = "1073741823";
PRAGMA page_size = "32767";
PRAGMA recursive_triggers = "0";
PRAGMA secure_delete = "1";
PRAGMA temp_store = "2";
PRAGMA wal_autocheckpoint = "1000";
PRAGMA user_version = "0";
.output stdout

BEGIN TRANSACTION;
${modification[*]}
COMMIT;

.quit
SQLITE
        fi
    fi
}

__um_compact()
{
    echo "Compact database" 1>&2

    sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output stdout

BEGIN TRANSACTION;
DELETE FROM tbl_authorities WHERE rowid NOT IN (SELECT tbl_authorities_key FROM tbl_urimark);
DELETE FROM tbl_parts WHERE rowid NOT IN (SELECT tbl_parts_key FROM tbl_urimark);
DELETE FROM tbl_tags WHERE rowid NOT IN (SELECT tbl_tags_key FROM tbl_tags_urimark);
DELETE FROM tbl_tags_urimark WHERE tbl_urimark_id NOT IN (SELECT id FROM tbl_urimark);
COMMIT;

VACUUM;
PRAGMA INTEGRITY_CHECK;
.output "${URIMARK_DATA_DIR}/next.id"

SELECT id_next FROM view_calc_id_next;

.quit
SQLITE

    exit $?
}

__um_initialize ()
{
    echo "Initialize database" 1>&2

    [[ -f ${URIMARK_DATA_DIR}/urimark.sqlite ]] && {
        sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output stderr

SELECT "urimark: '${URIMARK_DATA_DIR}/urimark.sqlite' has " || id || " records"
FROM view_calc_id_number;

.quit
SQLITE
        rm -i -- "${URIMARK_DATA_DIR}/urimark.sqlite"
        (($? == 0)) || exit $?
    }

    sqlite3 "${URIMARK_DATA_DIR}/urimark.sqlite" <<-SQLITE
.bail on
.log "${URIMARK_DATA_DIR}/urimark.log"
.output stdout
.read "${URIMARK_CONF_FILE%/*}/um_ini.sql"
PRAGMA INTEGRITY_CHECK;
.output "${URIMARK_DATA_DIR}/next.id"

SELECT id_next FROM view_calc_id_next;

.quit
SQLITE

    exit $?
}

__um_main ()
{
    declare \
        predir_confile=${XDG_CONFIG_HOME:-${HOME}/.config} \
        predir_datadir=${XDG_DATA_HOME:-${HOME}/.local/share}
    declare -r \
        URIMARK_CONF_FILE=${URIMARK_CONF_FILE:-${predir_confile}/urimark/urimark.conf} \
        URIMARK_DATA_DIR=${URIMARK_DATA_DIR:-${predir_datadir}/urimark/data}_ \
        URIMARK_TMP_DIR=${URIMARK_TMP_DIR:-"${TMPDIR:-/tmp}/urimark"}

    mkdir -p -- "${URIMARK_CONF_FILE%/*}" "$URIMARK_DATA_DIR"

    declare \
        arg= \
        args= \
        delim=\'

    declare -i \
        con= \
        pp=1

    declare -gA _um_options

    for arg in "${@#--}"
    do
        ((con == 1)) && { con= ; continue ; }
        case $arg in
            -[acdehimvnq!AOW])  args="${args}${arg} "                                       ;;
            -*[1-9DNPSUY])      args="${args}${arg} ${delim}${2}${delim} " ; pp=2 ; con=1   ;;
            add)                args="${args}-a "                                           ;;
            and)                args="${args}-A "                                           ;;
            auth=?*)                                                                        ;&
            authority=?*)       args="${args}-Y ${delim}${arg#*=}${delim} "                 ;;
            ct=?*)                                                                          ;&
            ctime=?*)           args="${args}-2 ${delim}${arg#*=}${delim} "                 ;;
            com)                                                                            ;&
            compact)            args="${args}-c "                                           ;;
            del)                                                                            ;&
            delete)             args="${args}-d "                                           ;;
            desc=?*)                                                                        ;&
            description=?*)     args="${args}-D ${delim}${arg#*=}${delim} "                 ;;
            edit)               args="${args}-e "                                           ;;
            help)               args="${args}-h "                                           ;;
            id=?*)              args="${args}-1 ${delim}${arg#*=}${delim} "                 ;;
            init)                                                                           ;&
            initialize)         args="${args}-i "                                           ;;
            mt=?*)                                                                          ;&
            mtime=?*)           args="${args}-3 ${delim}${arg#*=}${delim} "                 ;;
            modi)                                                                           ;&
            modify)             args="${args}-m "                                           ;;
            name=?*)            args="${args}-N ${delim}${arg#*=}${delim} "                 ;;
            nv)                                                                             ;&
            non-interactive)    args="${args}-n "                                           ;;
            not)                args="${args}-! "                                           ;;
            or)                 args="${args}-O "                                           ;;
            part=?*)            args="${args}-P ${delim}${arg#*=}${delim} "                 ;;
            query)              args="${args}-q "                                           ;;
            ref=?*)                                                                         ;&
            reference=?*)       args="${args}-7 ${delim}${arg#*=}${delim} "                 ;;
            ref+=?*)                                                                        ;&
            reference+=?*)      args="${args}-8 ${delim}${arg#*+=}${delim} "                ;;
            ref-=?*)                                                                        ;&
            reference-=?*)      args="${args}-9 ${delim}${arg#*-=}${delim} "                ;;
            scheme=?*)          args="${args}-S ${delim}${arg#*=}${delim} "                 ;;
            tag=?*)             args="${args}-4 ${delim}${arg#*=}${delim} "                 ;;
            tag+=?*)            args="${args}-5 ${delim}${arg#*+=}${delim} "                ;;
            tag-=?*)            args="${args}-6 ${delim}${arg#*-=}${delim} "                ;;
            uri=?*)             args="${args}-U ${delim}${arg#*=}${delim} "                 ;;
            version)            args="${args}-v "                                           ;;
            where)              args="${args}-W "                                           ;;
            auth=|\
            authority=|\
            authority|\
            auth|\
            ct=|\
            ctime=|\
            ctime|\
            ct|\
            desc=|\
            description=|\
            description|\
            desc|\
            id=|\
            id|\
            mt=|\
            mtime=|\
            mtime|\
            mt|\
            name=|\
            name|\
            part=|\
            part|\
            ref+=|\
            ref+|\
            ref-=|\
            ref-|\
            ref=|\
            reference+=|\
            reference+|\
            reference-=|\
            reference-|\
            reference=|\
            reference|\
            ref|\
            scheme=|\
            scheme|\
            tag+=|\
            tag+|\
            tag-=|\
            tag-|\
            tag=|\
            tag|\
            uri=|\
            uri)
                                { printf '%s\n' "Option '$1' requires an argument" 1>&2 ; exit 1 ; } ;;
            -)                  { printf '%s\n' "Option required: '$1'" 1>&2 ; exit 1 ; }            ;;
            *)                  #args="${args}${delim}${arg}${delim} "
                                _um_options[hook_chosen]=$arg
        esac
        shift "$pp" && pp=1
    done

    declare opt=
    declare -ga _um_sets=()
    #declare -gA _um_options

    function __um_parse_opt
    if [[ $OPTARG == -?* ]]
    then
        { printf '%s\n' "Option '-${opt}' requires an argument" 1>&2 ; exit 1 ; }
    else
        _um_sets+=("$1")
    fi

    eval set -- "$args"
    while getopts :1:2:3:4:5:6:7:8:9:AacD:dehimN:nqOP:!S:U:vWY: opt
    do
        case $opt in
            !)  _um_sets+=(not)                                  ;;
            1)  __um_parse_opt "id=$OPTARG"                      ;;
            2)  __um_parse_opt "ct=$OPTARG"                      ;;
            3)  __um_parse_opt "mt=$OPTARG"                      ;;
            4)  __um_parse_opt "tag=$OPTARG"                     ;;
            5)  __um_parse_opt "tag+=$OPTARG"                    ;;
            6)  __um_parse_opt "tag-=$OPTARG"                    ;;
            7)  __um_parse_opt "reference=$OPTARG"               ;;
            8)  __um_parse_opt "reference+=$OPTARG"              ;;
            9)  __um_parse_opt "reference-=$OPTARG"              ;;
            A)  _um_sets+=(and)                                  ;;
            D)  __um_parse_opt "description=$OPTARG"             ;;
            N)  __um_parse_opt "name=$OPTARG"                    ;;
            O)  _um_sets+=(or)                                   ;;
            P)  __um_parse_opt "part=$OPTARG"                    ;;
            S)  __um_parse_opt "scheme=$OPTARG"                  ;;
            U)  __um_parse_opt "uri=$OPTARG"                     ;;
            W)  _um_sets+=(where)                                ;;
            Y)  __um_parse_opt "authority=$OPTARG"               ;;
            a)  _um_options[action]=add                          ;;
            c)  _um_options[action]=compact                      ;;
            d)  _um_options[action]=delete                       ;;
            e)  _um_options[action]=edit                         ;;
            h)  __um_help ; exit 0                               ;;
            i)  _um_options[action]=initialize                   ;;
            m)  _um_options[action]=modify                       ;;
            n)  _um_options[non_interactive]=non_interactive     ;;
            q)  _um_options[action]=query                        ;;
            v)  __um_version ; exit 0                            ;;
            :)  printf '%s\n' "Option '-${OPTARG}' requires an argument." 1>&2
                exit 1                                           ;;
            \?) printf '%s\n' "Unknown flag: '-${OPTARG}'." 1>&2
                exit 1
        esac
    done

    unset -v \
        arg \
        args \
        con \
        delim \
        opt \
        pp \
        predir_confile \
        predir_datadir

    declare -gA hook

    hook[um_default1 description]="Builtin default report: id, uri"
    hook[um_default1 postprocess]="| cut -d '|' -f1,4,5,6 | tr -d '\"' | tr '|' ' '"
    hook[um_default2 description]="Builtin default report: csv_quoted"
    hook[um_default2 postprocess]=""

    [[ -f $URIMARK_CONF_FILE ]] && source "$URIMARK_CONF_FILE"

    _um_options[editor]=${_um_options[editor]:-$EDITOR}
    [[ ${hook[${_um_options[hook_default]} description]} ]] || _um_options[hook_default]=um_default1
    #~ _um_options[tag_default]=${_um_options[tag_default]:-NULL}
    #~ _um_options[reference_default]=${_um_options[reference_default]:-NULL}
    #~ _um_options[description_default]=${_um_options[description_default]:-NULL}
    #~ _um_options[hierarchy_default]=${_um_options[hierarchy_default]:-NULL}
    #~ _um_options[name_default]=${_um_options[name_default]:-NULL}

    #~ while (($# > 0))
    #~ do
        #~ case $1 in
            #~ -[AacdehiMmnO!vW])
                #~ shift 1
                #~ ;;
            #~ -*[1-9UDNSPY])
                #~ shift 2
                #~ ;;
            #~ *)
                #~ if [[ ${hook[${1} description]} ]]
                #~ then
                    #~ _um_options[hook_chosen]=$1
                    #~ shift 1
                #~ else
                    #~ { printf '%s\n' "Unknown parameter: '${1}'." 1>&2 ; exit 1 ; }
                #~ fi
        #~ esac
    #~ done

    if [[ ${hook[${_um_options[hook_chosen]:-${_um_options[hook_default]}} description]} ]]
    then
        _um_options[hook_chosen]=${_um_options[hook_chosen]:-${_um_options[hook_default]}}
        [[ ${hook[${_um_options[hook_chosen]} filter]} && ${#_um_sets[@]} -eq 0 ]] && \
            _um_sets=(${hook[${_um_options[hook_chosen]} filter]})
    else
        { printf '%s\n' "Unknown parameter: '${_um_options[hook_chosen]}'" 1>&2 ; exit 1 ; }
    fi

    case ${_um_options[action]} in
        add)
            __um_add "${_um_sets[@]}"
            ;;
        delete)
            __um_delete "${_um_sets[@]}"
            ;;
        edit)
            __um_edit "${_um_sets[@]}"
            ;;
        modify)
            declare -ga _um_assignments=()
            declare \
                i= \
                where=
            for i in "${!_um_sets[@]}"
            do
                if [[ $where == where ]]
                then
                    continue
                else
                    if [[ ${_um_sets[$i]} == where ]]
                    then
                        where=where
                    else
                        _um_assignments+=("${_um_sets[$i]}")
                    fi
                    unset -v "_um_sets[$i]"
                fi
            done
            unset -v i where
            __um_modify "${_um_sets[@]}"
            ;;
        initialize)
            __um_initialize
            ;;
        compact)
            __um_compact
            ;;
        query)
            ;&
        *)
            _um_options[action]=query
            __um_query "${_um_sets[@]}"
            exit $?
    esac
}

# -- MAIN.

__um_main "$@"
