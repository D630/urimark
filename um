#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/urimark

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/um.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__um_version() { echo "0.2.6.6" ; }

__um_usage() { printf 'um (-A|-c|-d|-e|-h|-i|-l|-m|-s|-v)' ; }

__um_help()
{
    printf "$(__um_usage)

SUBCOMMANDS
-----------
    ACTION                      OPT
    ------                      ---
    -A, --add                   -1,-2,-5,-8,-H,-N
    -c, --cloud=<CFIELD>
    -d, --delete                -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-n,
                                -o,-S,-T,-Y
    -e, --edit                  -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-o,
                                -S,-T,-Y
    -h, --help
    -i, --info
    -l, --list                  -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-o,
                                -S,-T,-u,-Y
    -m, --modify                -0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-!,-a,-B,
                                -H,-I,-M,-N,-n,-o,-S,-T,-Y
    -s, --search                -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-o,
                                -P,-S,-T,-u,-Y
    -v, --version

    OPT                         ARG
    ---                         ---
    -0, --uuid=                 <UUID>
    -1, --uri=                  <URI>
    -2, --tag=                  <TAG>
    -3, --tag+=                 <TAG>
    -4, --tag-=                 <TAG>
    -5, --reference=            <REF>
    -6, --reference+=           <REF>
    -7, --reference-=           <REF>
    -8, --description=          <DESC>
    -9, --mod
    -a, --and
    -B, --bd=                   <BD>
    -H, --hierarchy=            <HIER>
    -I, --id=                   <ID>
    -M, --md=                   <MD>
    -N, --name=                 <NAME>
    -n, --non-interactive
    -!, --not
    -o, --or
    -P, --absolute-path
    -S, --scheme=               <SCHEME>
    -T, --part=                 <PART>
    -u, --print-uri
    -Y, --authority=            <AUTH>

ARGUMENTS
---------
    <AUTH>*                     'string'
    <BD>*                       'date' or 'date,date'
    <CFIELD>                    'scheme', 'authority', 'part',
                                'hierarchy', 'tag' or 'reference'
    <DESC>*                     'string'
    <HIER>*                     '/foo/bar'
    <ID>*                       'int', 'int,int', 'int-int' (or combi)
    <MD>*                       'date' or 'date,date'
    <NAME>*                     'string'
    <PART>*                     'string'
    <REF>*                      'int' or 'int,int'
    <SCHEME>                    'http','https','ftp','ftps','dav','davs',
                                'gopher','webdav','webdavs
    <TAG>*                      'string' or 'string;string;string'
    <URI>                       'string'
    <UUID>*                     'uuid'

    *regextype: posix-egrep
"
}

__um_search()
{
    declare \
        f= \
        i= \
        id= \
        j= \
        not= \
        operator= \
        pattern= \
        pattern1= \
        pattern2= \
        search_uri_authority= \
        search_uri_schemes= \
        search_uri_schemes_specific_parts= \
        val= \
        var=

    declare -a \
        ids=() \
        utc=()

    declare -gA operators

    __um_search_parse_val()
    {
        if [[ $val =~ ^\^ ]]
        then
            pattern=${val#^}
        else
            pattern=${val/#/.\*}
        fi

        if [[ $pattern =~ \$$ ]]
        then
            pattern=${pattern/%$/}
        else
            pattern=${pattern/%/.\*}
        fi
    }

    if (($# == 0))
    then
        operators[or]=1
        cut -d '|' -f1,2 "${datadir}/_index" | \
            tr -d '"' | \
            tr '|' ' ' \
            > "${tmpdir}/or1"
    else
        for i
        do
            read -r var val <<< "${i/=/ }"
            if [[ $var == and ]]
            then
                operator=and
                operators[and]=$((${operators[and]} + 1))
            elif [[ $var == not ]]
            then
                if [[ $1 == not ]]
                then
                    shift 1
                    operator=or
                    not=not
                else
                    operator=not
                fi
            elif [[ $var == or ]]
            then
                operator=or
            else
                operator=${operator:-or}
                operators[$operator]=${operators[$operator]:-1}
                case $var in
                    uuid)
                            __um_search_parse_val
                            find -H "$datadir" -mindepth 2 -type f \
                                    ! -name _index -regextype posix-egrep \
                                    ${not:+\!} -regex "^${datadir}/${pattern}/.*$" \
                                    -printf '%P\n' | \
                                tr '/' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    authority)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){5}\"${pattern}\"\|(\".*\"(\||)){6}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    md)
                            for j in ${val//,/ }
                            do
                                if [[ $j =~ ^[[:digit:]]*$ ]]
                                then
                                    utc+=($j)
                                else
                                    utc+=($(date --utc --date "$j" +%s))
                                fi
                            done
                            if ((${#utc[@]} == 1))
                            then
                                __um_search_parse_val
                                egrep ${not:+-v} \
                                        -e "^(\".*\"\|){3}\"${pattern}\"\|(\".*\"(\||)){8}$" \
                                        "${datadir}/_index" | \
                                    cut -d '|' -f1,2 | \
                                    tr -d '"' | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            elif (( ${#utc[@]} == 2 )) # ü
                            then
                                pattern1=$(__um_search_binary ${utc[0]} 1 4)
                                pattern2=$(__um_search_binary ${utc[1]} 2 4)

                                cut -d '|' -f1,2,4 "${datadir}/_index" | \
                                    tr -d '"' | \
                                    sort -t '|' -k3 -n | \
                                    sed -n -e "/|${pattern1}$/,/|${pattern2}$/ p" \
                                        -e "/|${pattern2}$/ p" | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    bd)
                            for j in ${val//,/ }
                            do
                                if [[ $j =~ ^[[:digit:]]*$ ]]
                                then
                                    utc+=($j)
                                else
                                    utc+=($(date --utc --date "$j" +%s))
                                fi
                            done
                            if ((${#utc[@]} == 1))
                            then
                                __um_search_parse_val
                                egrep ${not:+-v} \
                                        -e "^(\".*\"\|){2}\"${pattern}\"\|(\".*\"(\||)){9}$" \
                                        "${datadir}/_index" | \
                                    cut -d '|' -f1,2 | \
                                    tr -d '"' | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            elif (( ${#utc[@]} == 2 )) #ü
                            then
                                pattern1=$(__um_search_binary ${utc[0]} 1 3)
                                pattern2=$(__um_search_binary ${utc[1]} 2 3)

                                cut -d '|' -f1,2,3 "${datadir}/_index" | \
                                    tr -d '"' | \
                                    sort -t '|' -k3 -n | \
                                    sed -n -e "/|${pattern1}$/,/|${pattern2}$/ p" \
                                        -e "/|${pattern2}$/ p" | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    scheme)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){4}\"${pattern}\"\|(\".*\"(\||)){7}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    part)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){6}\"${pattern}\"\|(\".*\"(\||)){5}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    description)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){8}\"${pattern}\"\|(\".*\"(\||)){3}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    name)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){7}\"${pattern}\"\|(\".*\"(\||)){4}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    hierarchy)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){9}\"${pattern}\"\|(\".*\"(\||)){2}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    tag)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){10}\"(.*${pattern}.*)\"(\|.*)$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    reference)
                            __um_search_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){11}\"(.*${pattern}.*)\"$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                    id)
                            if [[ $val =~ - ]]
                            then
                                for id in ${val//-/ }
                                do
                                    if [[ $id =~ ^\^ ]]
                                    then
                                        id=${id#^}
                                    else
                                        id=${id/#/.\*}
                                    fi
                                    if [[ $id =~ \$$ ]]
                                    then
                                        id=${id/%$/}
                                    else
                                        id=${id/%/.\*}
                                    fi
                                    ids+=($id)
                                done
                                while :
                                do
                                    if [[ $(tmpdir=${tmpdir}_ ; \
                                        __um_search id=^${ids[0]}$ 2>/dev/null && \
                                        __um_search_post 2>/dev/null) ]]
                                    then
                                        break
                                    else
                                        ids[0]=$((${ids[0]} + 1))
                                    fi
                                done
                                while :
                                do
                                    if [[ $(tmpdir=${tmpdir}_ ; \
                                        __um_search id=^${ids[1]}$ 2>/dev/null && \
                                        __um_search_post 2>/dev/null) ]]
                                    then
                                        break
                                    else
                                        ids[1]=$((${ids[1]} - 1))
                                    fi
                                done
                                cut -d '|' -f1,2 "${datadir}/_index" | \
                                    tr -d '"' | \
                                    tr '|' ' ' | \
                                    sort -k2 -n | \
                                    sed -n \
                                        -e "/^.* ${ids[0]}$/,/^.* ${ids[1]}$/${not:+!}p" \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            elif [[ $val =~ , ]]
                            then
                                for id in ${val//,/ }
                                do
                                    if [[ $id =~ ^\^ ]]
                                    then
                                        id=${id#^}
                                    else
                                        id=${id/#/.\*}
                                    fi

                                    if [[ $id =~ \$$ ]]
                                    then
                                        id=${id/%$/}
                                    else
                                        id=${id/%/.\*}
                                    fi
                                    ids+=($id)
                                done
                                printf -v pattern '%s|' ${ids[*]}
                                pattern=${pattern%|}
                                egrep ${not:+-v} \
                                    -e "^(\".*\"\|){1}\"(${pattern})\"\|(\".*\"(\||)){10}$" \
                                    "${datadir}/_index" | \
                                    cut -d '|' -f1,2 | \
                                    tr -d '"' | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            else
                                __um_search_parse_val
                                egrep ${not:+-v} \
                                    -e "^(\".*\"\|){1}\"${pattern}\"\|(\".*\"(\||)){10}$" \
                                    "${datadir}/_index" | \
                                    cut -d '|' -f1,2 | \
                                    tr -d '"' | \
                                    tr '|' ' ' \
                                    >> "${tmpdir}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    uri)
                            search_uri_schemes=${val%%:*}
                            IFS='/' read -r search_uri_authority \
                                search_uri_schemes_specific_parts \
                                <<< "${val##*://}"
                            search_uri_schemes_specific_parts=/${search_uri_schemes_specific_parts}
                            egrep ${not:+-v} \
                                    -e "^(\".*\"\|){4}\"${search_uri_schemes}\"\|\"${search_uri_authority}\"\|\"${search_uri_schemes_specific_parts}\"\|(\".*\"(\||)){5}$" \
                                    "${datadir}/_index" | \
                                cut -d '|' -f1,2 | \
                                tr -d '"' | \
                                tr '|' ' ' \
                                >> "${tmpdir}/${operator}${operators[$operator]}"
                            ;;
                esac
                ids=()
                utc=()
                not=
            fi
        done
    fi
}

__um_search_binary() #ü
{
    declare \
            b= \
            begin= \
            e= \
            end= \
            middle= \
            pattern=

    declare -a array=()

    pattern=$1
    if (($2 == 1))
    then
        b=1
    else
        e=1
    fi
    array=($(cut -d '|' -f "$3" "${datadir}/_index" | \
        tr -d '"' | \
        sort -n))
    begin=0
    end=$((${#array[@]} - 1))

    while ((begin <= end))
    do
        middle=$((begin + (end-begin) / 2))
        if ((${array[middle]} >= pattern))
        then
            if ((e && ${array[middle+1]:-${array[middle]}} <= pattern))
            then
                break
            else
                end=$((middle - 1))
            fi
        elif ((${array[middle]} <= pattern))
        then
            if ((b && ${array[middle+1]:-${array[middle]}} >= pattern))
            then
                break
            else
                begin=$((middle + 1))
            fi
        fi
    done

    printf '%s\n' "${array[middle]}"
}

__um_search_post()
{
    if [[ ${operators[and]} -eq 1 ]]
    then
        __um_search_post_and() { sort "${tmpdir}/and1" | uniq ; }
    elif [[ ${operators[and]} -gt 1 ]]
    then
        __um_search_post_and()
        {
            diff --unchanged-group-format='%=' \
                    --old-group-format='' --new-group-format='' \
                    --changed-group-format='' --from-file ${tmpdir}/and* | \
                sort | \
                uniq
        }
    fi

    if [[ ${operators[or]} && ${operators[and]} ]]
    then
        __um_search_post_or()
        {
            comm -12 <(sort "${tmpdir}/or1") <(__um_search_post_and) | \
            sort | \
            uniq
        }
    elif ((${operators[or]}))
    then
        __um_search_post_or() { sort "${tmpdir}/or1" | uniq ; }
    fi

    if [[ ${operators[or]} && ${operators[not]} ]]
    then
        if [[ $path_absolute ]]
        then
            sed -n "s|^\(.*\) \(.*\)$|${datadir}\/\1\/\2|p" \
                <(comm -23 <(__um_search_post_or) \
                <(sort "${tmpdir}/not1" | uniq))
        else
            comm -23 <(__um_search_post_or) \
                <(sort "${tmpdir}/not1" | uniq)
        fi
    else
        if [[ $path_absolute ]]
        then
            sed -n "s|^\(.*\) \(.*\)$|${datadir}\/\1\/\2|p" \
                <(__um_search_post_or)
        else
            __um_search_post_or
        fi
    fi
}

__um_add()
{
    declare \
        aid= \
        authority= \
        auuid= \
        bd= \
        date= \
        description= \
        hierarchy= \
        i= \
        id= \
        md= \
        name= \
        part= \
        scheme= \
        succeeded= \
        uri= \
        uuid=

    declare -a \
        references=() \
        tags=()

    declare -ga dir_stack=()

    if (($# == 0))
    then
        read -re -p "URI: " uri
        if [[ ! $uri =~ ^(http|https|ftp|ftps|dav|davs|gopher|webdav|webdavs):// ]]
        then
            { echo "Wrong scheme." 1>&2 ; return 1 ; }
        elif [[ $(tmpdir=${tmpdir}_ ; __um_search uri="${uri}" 2>/dev/null && \
            __um_search_post 2>/dev/null) ]]
        then
            { echo "URI '$uri' has already been recorded." 1>&2 ; return 1 ; }
        fi
        read -re -p "Name: " name
        read -re -p "Description: " description
        IFS=';' read -re -p "Tags: " -a tags
        read -re -p "Hierarchy: " hierarchy
        IFS=';' read -re -p "References: " -a references
    else
        for i
        do
            case $i in
                uri=*)
                        uri=${i#*=}
                        if [[ ! $uri =~ ^(http|https|ftp|ftps|dav|davs|gopher|webdav|webdavs):// ]]
                        then
                            { echo "Wrong scheme." 1>&2 ; return 1 ; }
                        elif [[ $(tmpdir=${tmpdir}_ ; __um_search uri="${uri}" 2>/dev/null && \
                                __um_search_post 2>/dev/null) ]]
                        then
                            { echo "URI '$uri' has already been recorded." 1>&2 ; return 1 ; }
                        fi
                        ;;
                name=*)
                        name=${i#*=}
                        ;;
                description=*)
                        description=${i#*=}
                        ;;
                hierarchy=*)
                        hierarchy=${i#*=}
                        ;;
                tag=*)
                        IFS=';' read -r -a tags <<< "${i#*=}"
                        ;;
                reference=*)
                        IFS=';' read -r -a references <<< "${i#*=}"
                        ;;
            esac
        done
        [[ ! $uri ]] && { echo "We need an URI to record." 1>&2 ; return 1 ; }
    fi

    date=$(date --utc --date now +%s)

    ((${#tags[@]} == 0)) && tags[0]=null
    ((${#references[@]} == 0)) && references[0]=null

    bd=$date
    md=$date
    id=$(__um_calculating_id)
    id=${id:-1}

    scheme=${uri%%:*}
    IFS='/' read -r authority part <<< "${uri##*://}"
    part=/${part%%/}

    read -r auuid aid < <(__um_search authority=^${authority}$ && \
        __um_search_post)
    if [[ $auuid && $aid ]]
    then
        uuid=$auuid
        pushd "$uuid" 1>/dev/null
        printf '%s\n' "Authority has already been recorded at file://${datadir}/${auuid} ." 1>&2
        __um_add_print && succeeded=succeeded
    else
        uuid=$(__um_random 8)
        mkdir -p "${datadir}/${uuid}" && printf '%s\n' "New authority has been recorded at file://${datadir}/${uuid} ." 1>&2
        pushd "$uuid" 1>/dev/null
        __um_add_print && succeeded=succeeded
    fi

    if [[ $succeeded ]]
    then
        printf '%s\n' "New URI with id ${id} has been recorded." 1>&2
        dir_stack=($(dirs -l -p))
        echo "Index is being rebuild..." 1>&2
    else
         { printf '%s\n' "URI has not been recorded." 1>&2 ; return 1 ; }
    fi
}

__um_add_print()
{
    declare \
            j= \
            k=

    exec 3>"${datadir}/${uuid}/${id}"

    printf '%s\n' "uuid=$uuid
date_build=$bd
date_modification=$md
uri_authority=\"${authority}\"
uri_scheme=\"${scheme}\"
uri_scheme_specific_part=\"${part}\"
uri_scheme_specific_part_description=\"${description:-null}\"
uri_scheme_specific_part_hierarchy=\"${hierarchy:-null}\"
uri_scheme_specific_part_name=\"${name:-null}\"
uri_scheme_specific_part_id=$id" >&3

    for j in "${!references[@]}"
    do
        printf '%s\n' "uri_scheme_specific_part_reference[$j]=${references[$j]}"
    done 1>&3

    for k in "${!tags[@]}"
    do
        printf '%s\n' "uri_scheme_specific_part_tag[$k]=\"${tags[$k]}\""
    done 1>&3

    exec 3<&-
}

__um_edit()
{
    declare \
        date= \
        date_build= \
        date_modification= \
        eid= \
        euuid= \
        file_tmp= \
        j= \
        k= \
        md5_post= \
        md5_pre= \
        modification= \
        uri_authority= \
        uri_scheme= \
        uri_scheme_specific_part= \
        uri_scheme_specific_part_description= \
        uri_scheme_specific_part_hierarchy= \
        uri_scheme_specific_part_id= \
        uri_scheme_specific_part_name= \
        uuid=

    declare -ga dir_stack=()

    declare -a \
       uri_scheme_specific_part_reference=() \
       uri_scheme_specific_part_tag=()

    if (($# == 0))
    then
        { echo "No arguments has been specified." 1>&2 ; return 1 ; }
    else
        while read -r euuid eid
        do
            file_tmp=$(mktemp ${tmpdir}/urimark.XXXXXX)
            cp -- "${datadir}/${euuid}/${eid}" "$file_tmp"
            pushd "$euuid" >/dev/null
            md5_pre=$(md5sum "$file_tmp")
            $editor "$file_tmp" </dev/tty
            date=$(date --utc --date now +%s)
            md5_post=$(md5sum "$file_tmp")
            if [[ $md5_pre != $md5_post ]]
            then
                (
                    source "$file_tmp"
                    date_modification=$date
                    {
                        printf '%s\n' "uuid=$uuid
date_build=$date_build
date_modification=$date_modification
uri_authority=\"${uri_authority}\"
uri_scheme=\"${uri_scheme}\"
uri_scheme_specific_part=\"${uri_scheme_specific_part}\"
uri_scheme_specific_part_description=\"${uri_scheme_specific_part_description}\"
uri_scheme_specific_part_hierarchy=\"${uri_scheme_specific_part_hierarchy}\"
uri_scheme_specific_part_name=\"${uri_scheme_specific_part_name}\"
uri_scheme_specific_part_id=$uri_scheme_specific_part_id"
                        for j in "${!uri_scheme_specific_part_reference[@]}"
                        do
                            printf '%s\n' "uri_scheme_specific_part_reference[$j]=${uri_scheme_specific_part_reference[$j]}"
                        done
                        for k in "${!uri_scheme_specific_part_tag[@]}"
                        do
                            printf '%s\n' "uri_scheme_specific_part_tag[$k]=\"${uri_scheme_specific_part_tag[$k]}\""
                        done
                    } > "${datadir}/${euuid}/${eid}"
                    echo "Data set with id $eid has been modified." 1>&2
                )
                modification=modification
            else
                echo "Data set with id $eid has not been modified." 1>&2
            fi
        done < <(__um_search "$@" && __um_search_post)
        [[ $modification == modification ]] &&
        {
            dir_stack=($(dirs -l -p))
            __um_rebuild_index
        }
    fi
}

__um_delete()
{
    declare \
        d= \
        delete_all= \
        response=

    declare -a deletion=()

    declare -ga dir_stack=()

    if (($# == 0))
    then
        { echo "We need an argument." 1>&2 ; return 1 ; }
    else
        while read -r
        do
            if [[ $delete_all == delete_all || $non_interactive == non_interactive ]]
            then
                deletion+=("$REPLY")
            else
                printf 'UUID: %s\nID:   %s\n' $REPLY
                read -u 3 -p "Do you really wanne delete this record? (y/n/all/quit) " response
                case $response in
                    all)    delete_all=delete_all        ;&
                    y|yes)  deletion+=("$REPLY")         ;;
                    n|no)   continue                    ;;
                    quit)   deletion=() ; break         ;;
                    *)      continue                    ;;
                esac
            fi
        done 3<&0 < <(__um_search "$@" && __um_search_post)

        if ((${#deletion[@]} != 0))
        then
            for d in "${deletion[@]}"
            do
                pushd "${d% *}" >/dev/null
                rm -- "${datadir}/${d% *}/${d#* }"
            done
            dir_stack=($(dirs -l -p))
            rm -- "${datadir}/${d% *}/_index" 2>/dev/null
            echo "Records have been deleted." 1>&2
        else
            { echo "No Record has been deleted." 1>&2 ; return 1 ; }
        fi
    fi
}

__um_modify()
{
    declare \
        date= \
        i= \
        j= \
        k= \
        modify_all= \
        record= \
        ref= \
        response= \
        tag=

    declare -a \
       modification=() \
       references=() \
       tags=()

    declare -ga dir_stack=()

    if ((${#mods[@]} == 0))
    then
         { echo "We need to specify a modification pattern." 1>&2 ; return 1 ; }
    else
        for i in "${!mods[@]}"
        do
            case ${mods[i]} in
                authority=*)
                        mods[i]="-e s|^uri_authority=.*$|uri_authority=\"${mods[i]#*=}\"|"
                        ;;
                scheme=*)
                        mods[i]="-e s|^uri_scheme=.*$|uri_scheme=\"${mods[i]#*=}\"|"
                        ;;
                part=*)
                        mods[i]="-e s|^uri_scheme_specific_part=.*$|uri_scheme_specific_part=\"${mods[i]#*=}\"|"
                        ;;
                name=*)
                        mods[i]="-e s|^uri_scheme_specific_part_name=.*$|uri_scheme_specific_part_name=\"${mods[i]#*=}\"|"
                        ;;
                description=*)
                        mods[i]="-e s|^uri_scheme_specific_part_description=.*$|uri_scheme_specific_part_description=\"${mods[i]#*=}\"|"
                        ;;
                hierarchy=*)
                        mods[i]="-e s|^uri_scheme_specific_part_hierarchy=.*$|uri_scheme_specific_part_hierarchy=\"${mods[i]#*=}\"|"
                        ;;
                tag=*)
                        for j in "${patterns[@]}"
                        do
                            [[ $j == tag=* ]] && tags+=("${j#*=}")
                        done
                        printf -v tag '%s|' "${tags[@]//^/}"
                        tag=${tag//$/}
                        mods[i]="-e s|^(uri_scheme_specific_part_tag\[.*\]=)\"(${tag%|*})\"$|\1\"${mods[i]#*=}\"|"
                        ;;
                tag-=*)
                        mods[i]="-e /^uri_scheme_specific_part_tag\[.*\]=\"${mods[i]#*=}\"$/d"
                        ;;
                tag+=*)
                        index=$(__um_random 4)
                        mods[i]="-e $ i uri_scheme_specific_part_tag[${index}]=\"${mods[i]#*=}\""
                        ;;
                reference=*)
                        for k in "${patterns[@]}"
                        do
                            [[ $k == reference=* ]] && references+=("${k#*=}")
                        done
                        printf -v ref '%s|' "${references[@]//^/}"
                        ref=${ref//$/}
                        mods[i]="-e s|^(uri_scheme_specific_part_reference\[.*\]=)(${ref%|*})$|\1${mods[i]#*=}|"
                        ;;
                reference-=*)
                        mods[i]="-e /^uri_scheme_specific_part_reference\[.*\]=${mods[i]#*=}$/d"
                        ;;
                reference+=*)
                        index=$(__um_random 4)
                        mods[i]="-e $ i uri_scheme_specific_part_reference[${index}]=${mods[i]#*=}"
                        ;;
                *)
                        unset -v "mods[i]"
                        ;;
            esac
        done

        while read -r
        do
            if [[ $modify_all=modify_all  || $non_interactive=non_interactive ]]
            then
                modification+=("${datadir}/${REPLY% *}/${REPLY#* }")
                pushd "${REPLY% *}" >/dev/null
            else
                printf 'UUID: %s\nID:   %s\n' $record
                read -u 3 -p "Do you really wanne modify this record? (y/n/all/quit) " response
                case $response in
                    all)
                            modify_all=modify_all
                            ;&
                    y|yes)
                            modification+=("${datadir}/${REPLY% *}/${REPLY#* }")
                            pushd "${REPLY% *}" >/dev/null
                            ;;
                    n|no)
                            continue
                            ;;
                    quit)
                            modification=()
                            break
                            ;;
                    *)
                            continue
                            ;;
                esac
            fi
        done 3<&0 < <(__um_search "${patterns[@]}" && __um_search_post)

        if ((${#modification[@]} != 0))
        then
            dir_stack=($(dirs -l -p))
            date=$(date --utc --date now +%s)
            printf '%s\n' "${modification[@]}" | \
                xargs -r sed -r -i -e "/date_modification=.*/ c date_modification=${date}" "${mods[@]}"
            echo "Records have been modified." 1>&2
        else
            { echo "No Record has been modified." 1>&2 ; return 1 ; }
        fi
    fi
}

__um_list()
{
    if (($# == 0))
    then
        if [[ $build_uri ]]
        then
            sed -r -e 's#^(\".*\"\|\".*\"\|\".*\"\|\".*\")\|\"(.*)\"\|\"(.*)\"\|\"(.*)\"\|(\".*\"\|\".*\"\|\".*\"\|\".*\"\|\".*\")#\1\|"\2://\3\4"\|\5#' "${datadir}/_index"
        else
            cat "${datadir}/_index"
        fi
    else
        if [[ $build_uri ]]
        then
            fgrep -f <(__um_search "$@" && __um_search_post | sed 's/ /\"|\"/') "${datadir}/_index" | \
            sed -r -e 's#^(\".*\"\|\".*\"\|\".*\"\|\".*\")\|\"(.*)\"\|\"(.*)\"\|\"(.*)\"\|(\".*\"\|\".*\"\|\".*\"\|\".*\"\|\".*\")#\1\|"\2://\3\4"\|\5#'
        else
            fgrep -f <(__um_search "$@" && __um_search_post | sed 's/ /\"|\"/') "${datadir}/_index"
        fi
    fi
}

__um_cloud()
{
    declare field=

    case ${1#-} in
        authority)  field=6                                           ;;
        hierarchy)  field=10                                          ;;
        part)       field=7                                           ;;
        reference)  field=12                                          ;;
        scheme)     field=5                                           ;;
        tag)        field=11                                          ;;
        *)          echo "We need a suitable argument." 1>&2
                    return 1
    esac

    cut -d'|' -f "$field" "${datadir}/_index" | sed 's/"//g;s/;/\n/g' | sort | uniq -c | sort -nr
}

__um_info()
{
    printf '%s\n' "Authorities: $(find -H "$datadir" -maxdepth 1 -mindepth 1 -type d ! -name _index | sed -n '$=')" "URIs: $(sed -n '$=' "${datadir}/_index")"
}

__um_rebuild_index()
{
    declare \
        dir= \
        i=

    echo "Index is beeing rebuild..." 1>&2

    while read -r dir
    do
        declare -a \
           r_au=() \
           r_db=() \
           r_desc=() \
           r_dm=() \
           r_hier=() \
           r_id=() \
           r_name=() \
           r_part=() \
           r_ref=() \
           r_scheme=() \
           r_tag=() \
           r_uuid=() \
           uri_scheme_specific_part_reference=() \
           uri_scheme_specific_part_tag=()
        declare \
            date_build= \
            date_modification= \
            uri_authority= \
            uri_scheme= \
            uri_scheme_specific_part= \
            uri_scheme_specific_part_description= \
            uri_scheme_specific_part_hierarchy= \
            uri_scheme_specific_part_id= \
            uri_scheme_specific_part_name= \
            uuid=
        > "${dir}/_index"
        while read -r
        do
            source "$REPLY" 2>/dev/null &&
            {
                r_uuid+=($uuid)
                r_db+=($date_build)
                r_dm+=($date_modification)
                r_au+=("$uri_authority")
                r_id+=($uri_scheme_specific_part_id)
                r_scheme+=("$uri_scheme")
                r_part+=("$uri_scheme_specific_part")
                r_desc+=("$uri_scheme_specific_part_description")
                r_name+=("$uri_scheme_specific_part_name")
                r_hier+=("$uri_scheme_specific_part_hierarchy")
                r_ref+=("$(printf '%s;' "${uri_scheme_specific_part_reference[@]}")")
                r_tag+=("$(printf '%s;' "${uri_scheme_specific_part_tag[@]}")")
            }
            uri_scheme_specific_part_reference=()
            uri_scheme_specific_part_tag=()
        done < <(find -H "$dir" -mindepth 1 -maxdepth 1 -type f ! -name _index -print)
        exec 3>"${dir}/_index"
        for i in "${!r_uuid[@]}"
        do
            printf "%s\n" "\"${r_uuid[i]}\"|\"${r_id[i]}\"|\"${r_db[i]}\"|\"${r_dm[i]}\"|\"${r_scheme[i]}\"|\"${r_au[i]}\"|\"${r_part[i]}\"|\"${r_name[i]}\"|\"${r_desc[i]}\"|\"${r_hier[i]}\"|\"${r_tag[i]%;}\"|\"${r_ref[i]%;}\"" >&3
        done
        exec 3<&-
    done < <(printf '%s\n' "${dir_stack[@]}" | grep -e "${datadir}/.*" | sort | uniq)

    if (($? == 0))
    then
        { echo "Done." 1>&2 ; return 0 ; }
    else
        { echo "Undone." 1>&2 ; return 1 ; }
    fi
}

__um_cat_indexes() { find -H "$datadir" -mindepth 2 -type f -name _index \
    -print | xargs -r cat > "${datadir}/_index" ; }

__um_random()
{
    declare random=

    random=$(od -vAn -N "$1" -tu </dev/urandom)
    printf '%s\n' "${random// /}"
}

__um_calculating_id()
{
    printf '%s\n' "$(($(cut -d "|" -f2 "${datadir}/_index" | \
        tr -d '"' | \
        sort -n | \
        tail -n1)+1))"
}

__um_delete_empty_dirs() { find -H "$datadir" -maxdepth 1 -type d -empty -delete ; }

__um_check_args()
{
    declare o=
    if [[ ! $OPTARG =~ ^-.+ ]]
    then
        for o
        do
            patterns+=("$o")
        done
    else
        { printf '%s\n' "Option -${opt} requires an argument." >&2 ; exit 1 ; }
    fi
}

# -- MAIN.

declare -r predir_datadir=${XDG_DATA_HOME:-${HOME}/.local/share}
declare -r datadir=${URIMARK_DATA:-${predir_datadir}/urimark/data}
declare -r \
    CDPATH=$datadir \
    editor=${X_TTY_EDITOR:-nano}
declare tmpdir=${URIMARK_TMP:-"${TMPDIR:-/tmp}/urimark"}

trap "{ rm -fr "$tmpdir" "${tmpdir}_" ; exit 255 ; }" EXIT

[[ ! -e $datadir ]] && mkdir -p -- "$datadir"
mkdir -p -- "$tmpdir" "${tmpdir}_"

declare \
    arg= \
    args= \
    delim=\'

for arg
do
    arg=${arg#--}
    case $arg in
        absolute-path)      args="${args}-P "                               ;;
        add)                args="${args}-A "                               ;;
        and)                args="${args}-a "                               ;;
        "")                 args="${args}-- "                               ;;
        authority=*)        args="${args}-Y ${arg#*=} "                     ;;
        bd=*)               args="${args}-B ${arg#*=} "                     ;;
        cloud=*)            args="${args}-c ${arg#*=} "                     ;;
        delete)             args="${args}-d "                               ;;
        description=*)      args="${args}-8 ${delim}${arg#*=}${delim} "     ;;
        edit)               args="${args}-e "                               ;;
        help)               args="${args}-h "                               ;;
        hierarchy=*)        args="${args}-H ${arg#*=} "                     ;;
        id=*)               args="${args}-I ${arg#*=} "                     ;;
        info)               args="${args}-i "                               ;;
        list)               args="${args}-l "                               ;;
        md=*)               args="${args}-M ${arg#*=} "                     ;;
        mod)                args="${args}-9 "                               ;;
        modify)             args="${args}-m "                               ;;
        name=*)             args="${args}-N ${delim}${arg#*=}${delim} "     ;;
        non-interactive)    args="${args}-n "                               ;;
        not)                args="${args}-! "                               ;;
        or)                 args="${args}-o "                               ;;
        part=*)             args="${args}-T ${delim}${arg#*=}${delim} "     ;;
        print-uri)          args="${args}-u "                               ;;
        reference=*)        args="${args}-5 ${delim}${arg#*=}${delim} "     ;;
        reference+=*)       args="${args}-6 ${delim}${arg#*+=}${delim} "    ;;
        reference-=*)       args="${args}-7 ${delim}${arg#*-=}${delim} "    ;;
        scheme=*)           args="${args}-S ${arg#*=} "                     ;;
        search)             args="${args}-s "                               ;;
        tag=*)              args="${args}-2 ${delim}${arg#*=}${delim} "     ;;
        tag+=*)             args="${args}-3 ${delim}${arg#*+=}${delim} "    ;;
        tag-=*)             args="${args}-4 ${delim}${arg#*-=}${delim} "    ;;
        uri=*)              args="${args}-1 ${delim}${arg#*=}${delim} "     ;;
        uuid=*)             args="${args}-0 ${arg#*=} "                     ;;
        version)            args="${args}-v "                               ;;
        *)                  if [[ ${arg:0:1} == - ]]
                            then
                                args="${args}${arg} "
                            else
                                args="${args}${delim}${arg}${delim} "
                            fi
                            ;;
    esac
done

declare \
    action= \
    build_uri= \
    i= \
    mod= \
    non_interactive= \
    opt= \
    OPTIND=1 \
    path_absolute=

declare -a \
    mods=() \
    patterns=()

eval set -- "$args"
while getopts :sPAaY:B:c:d8:eH:I:ilM:9mN:n!oT:u5:6:7:S:2:3:4:0:1:hv opt
do
    case $opt in
            0)  __um_check_args "uuid=$OPTARG"                    ;;
            1)  __um_check_args "uri=$OPTARG"                     ;;
            2)  __um_check_args "tag=$OPTARG"                     ;;
            3)  __um_check_args "tag+=$OPTARG"                    ;;
            4)  __um_check_args "tag-=$OPTARG"                    ;;
            5)  __um_check_args "reference=$OPTARG"               ;;
            6)  __um_check_args "reference+=$OPTARG"              ;;
            7)  __um_check_args "reference-=$OPTARG"              ;;
            8)  __um_check_args "description=$OPTARG"             ;;
            9)  patterns+=(mod)                                   ;;
            A)  action=add                                        ;;
            a)  patterns+=(and)                                   ;;
            B)  __um_check_args "bd=$OPTARG"                      ;;
            c)  action=cloud ; __um_check_args "$OPTARG"          ;;
            d)  action=delete                                     ;;
            e)  action=edit                                       ;;
            h)  action=help                                       ;;
            H)  __um_check_args "hierarchy=$OPTARG"               ;;
            i)  action=info                                       ;;
            I)  __um_check_args "id=$OPTARG"                      ;;
            l)  action=list                                       ;;
            m)  action=modify                                     ;;
            M)  __um_check_args "md=$OPTARG"                      ;;
            n)  non_interactive=non_interactive                   ;;
            N)  __um_check_args "name=$OPTARG"                    ;;
            o)  patterns+=(or)                                    ;;
            !)  patterns+=(not)                                   ;;
            P)  path_absolute=path_absolute                       ;;
            s)  action=search                                     ;;
            S)  __um_check_args "scheme=$OPTARG"                  ;;
            T)  __um_check_args "part=$OPTARG"                    ;;
            u)  build_uri=build_uri                               ;;
            v)  action=version                                    ;;
            Y)  __um_check_args "authority=$OPTARG"               ;;
            :)  printf '%s\n' "Option -${OPTARG} requires an argument." >&2
                exit 1                                            ;;
            \?) printf '%s\n' "Unknown flag: -${OPTARG}." >&2
                exit 1
    esac
done
if (($# + 1 != $OPTIND))
then
    { printf '%s\n' "Command line does not fit: $*." 1>&2 ; exit 1 ; }
else
    shift $((OPTIND-1))
fi

case $action in
    add)
            __um_add "${patterns[@]}" &&
            {
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    cloud)
            __um_cloud "${patterns[0]}"
            ;;
    delete)
            __um_delete "${patterns[@]}" &&
            {
                __um_delete_empty_dirs
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    edit)
            __um_edit "${patterns[@]}"
            ;;
    help)
            __um_help
            ;;
    info)
            __um_info
            ;;
    list)
            __um_list "${patterns[@]}"
            ;;
    modify)
            for i in "${!patterns[@]}"
            do
                [[ ${patterns[$i]} == mod ]] && \
                    mod=mod && \
                    unset -v "patterns[$i]" && \
                    continue
                [[ $mod == mod ]] && \
                    mods+=("${patterns[$i]}") && \
                    unset -v "patterns[$i]"
            done
            __um_modify &&
            {
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    search)
            __um_search "${patterns[@]}" && __um_search_post
            ;;
    version)
            __um_version
            ;;
    *)
            { echo "No subcommand has been specified." 1>&2 ; exit 1 ; }
esac
