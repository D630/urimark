#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/urimark

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/um.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__um_version() { echo "0.2.9.1" ; }

__um_usage() { printf 'um (-A|-d|-e|-h|-m|-r|-v)' ; }

__um_help()
{
    printf "$(__um_usage)

SUBCOMMANDS
-----------
    ACTION                      OPT
    ------                      ---
    -A, --add                   -1,-2,-5,-8,-H,-N
    -d, --delete                -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-n,
                                -o,-S,-T,-Y
    -e, --edit                  -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-o,
                                -S,-T,-Y
    -h, --help
    -m, --modify                -0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-!,-a,-B,
                                -H,-I,-M,-N,-n,-o,-S,-T,-Y
    -r, --rebuild               -0,-1,-2,-5,-8,-!,-a,-B,-H,-I,-M,-N,-n,
                                -o,-S,-T,-Y
    -v, --version

    OPT                         ARG
    ---                         ---
    -0, --uuid=                 <UUID>
    -1, --uri=                  <URI>
    -2, --tag=                  <TAG>
    -3, --tag+=                 <TAG>
    -4, --tag-=                 <TAG>
    -5, --reference=            <REF>
    -6, --reference+=           <REF>
    -7, --reference-=           <REF>
    -8, --description=          <DESC>
    -9, --mod
    -a, --and
    -B, --bd=                   <BD>
    -H, --hierarchy=            <HIER>
    -I, --id=                   <ID>
    -M, --md=                   <MD>
    -N, --name=                 <NAME>
    -n, --non-interactive
    -!, --not
    -o, --or
    -S, --scheme=               <SCHEME>
    -T, --part=                 <PART>
    -Y, --authority=            <AUTH>

ARGUMENTS
---------
    <AUTH>*                     'string'
    <BD>                        'date'* or 'date;date'. Two special
                                values: 'first' and 'last'.
    <DESC>*                     'string'
    <HIER>*                     '/foo/bar'
    <ID>*                       'int', 'int,int', 'int-int' (or combi).
                                Two special values: 'first' and 'last'.
    <MD>                        'date'* or 'date;date'. Two special
                                values: 'first' and 'last'.
    <NAME>*                     'string'
    <PART>*                     'string'
    <REF>*                      'int' or 'int,int'
    <SCHEME>*                   'http','https','ftp','ftps','dav','davs',
                                'gopher','webdav','webdavs
    <TAG>*                      'string' or 'string;string;string'
    <URI>                       'string'
    <UUID>*                     'uuid'

    *regextype: posix-egrep
"
}

__um_query()
{
    declare \
        i= \
        id= \
        not= \
        operator= \
        pattern= \
        query_uri_authority= \
        query_uri_schemes= \
        query_uri_schemes_specific_parts= \
        time= \
        val= \
        var=

    declare -a \
        ids=() \
        times=()

    declare -gA operators

    __um_query_parse_val()
    {
        if [[ $val =~ ^\^ ]]
        then
            pattern=${val#^}
        else
            pattern=${val/#/.\*}
        fi

        if [[ $pattern =~ \$$ ]]
        then
            pattern=${pattern/%$/}
        else
            pattern=${pattern/%/.\*}
        fi
    }

    if (($# == 0))
    then
        operators[or]=1
        cut -d '|' -f 1,2 "${URIMARK_DATA_DIR}/_index" | \
            tr -d '"' | \
            tr '|' ' ' \
            > "${URIMARK_TMP_DIR}/or1"
    else
        for i
        do
            read -r var val <<< "${i/=/ }"
            if [[ $var == and ]]
            then
                operator=and
                operators[and]=$((${operators[and]} + 1))
            elif [[ $var == not ]]
            then
                if [[ $1 == not ]]
                then
                    shift 1
                    operator=or
                    not=not
                else
                    operator=not
                fi
            elif [[ $var == or ]]
            then
                operator=or
            else
                operator=${operator:-or}
                operators[$operator]=${operators[$operator]:-1}
                case $var in
                    uuid)
                            __um_query_parse_val
                            if [[ $action == rebuild ]]
                            then
                                find -H "$URIMARK_DATA_DIR" -mindepth 2 -type f \
                                        ! -name _index -regextype posix-egrep \
                                        ${not:+\!} -regex "^${URIMARK_DATA_DIR}/${pattern}/.*$" \
                                        -printf '%P\n' | \
                                    tr '/' ' ' \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            else
                                egrep ${not:+-v} \
                                        -e "^\"${pattern}\"\|(.*)$" "${URIMARK_DATA_DIR}/_index" \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    id)
                            [[ $val =~ first ]] && \
                                val=${val//first/$(__um_calculating_id first)}
                            [[ $val =~ last ]] && \
                                val=${val//last/$(__um_calculating_id last)}
                            if [[ $val =~ - ]]
                            then
                                for id in ${val//-/ }
                                do
                                    if [[ $id =~ ^\^ ]]
                                    then
                                        id=${id#^}
                                    else
                                        id=${id/#/.\*}
                                    fi
                                    if [[ $id =~ \$$ ]]
                                    then
                                        id=${id/%$/}
                                    else
                                        id=${id/%/.\*}
                                    fi
                                    ids+=($id)
                                done
                                while :
                                do
                                    if [[ $(URIMARK_TMP_DIR=${URIMARK_TMP_DIR}_ ; \
                                            __um_query id=^${ids[0]}$ 2>/dev/null && \
                                            __um_query_post 2>/dev/null) ]]
                                    then
                                        break
                                    else
                                        ids[0]=$((${ids[0]} + 1))
                                    fi
                                done
                                while :
                                do
                                    if [[ $(URIMARK_TMP_DIR=${URIMARK_TMP_DIR}_ ; \
                                            __um_query id=^${ids[1]}$ 2>/dev/null && \
                                            __um_query_post 2>/dev/null) ]]
                                    then
                                        break
                                    else
                                        ids[1]=$((${ids[1]} - 1))
                                    fi
                                done
                                sort -t '|' -k 2.2n "${URIMARK_DATA_DIR}/_index" | \
                                    sed -r -n \
                                        -e "/^(\"[^\"\|]*\"\|){1}\"${ids[0]}\"\|(\"[^\"\|]*\"\|){9}(\"[^\"\|]*\"){1}$/,/^(\"[^\"\|]*\"\|){1}\"${ids[1]}\"\|(\"[^\"\|]*\"\|){9}(\"[^\"\|]*\"){1}$/${not:+!}p" \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            elif [[ $val =~ , ]]
                            then
                                for id in ${val//,/ }
                                do
                                    if [[ $id =~ ^\^ ]]
                                    then
                                        id=${id#^}
                                    else
                                        id=${id/#/.\*}
                                    fi

                                    if [[ $id =~ \$$ ]]
                                    then
                                        id=${id/%$/}
                                    else
                                        id=${id/%/.\*}
                                    fi
                                    ids+=($id)
                                done
                                printf -v pattern '%s|' ${ids[*]}
                                pattern=${pattern%|}
                                egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){1}\"(${pattern})\"\|(\"[^\"\|]*\"\|){9}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            else
                                __um_query_parse_val
                                egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){1}\"${pattern}\"\|(\"[^\"\|]*\"\|){9}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    bd)
                            for time in ${val//;/ }
                            do
                                if [[ $time =~ ^\^ ]]
                                then
                                    time=${time#^}
                                else
                                    time=${time/#/.\*}
                                fi
                                if [[ $time =~ \$$ ]]
                                then
                                    time=${time/%$/}
                                else
                                    time=${time/%/.\*}
                                fi
                                if [[ $time =~ ^(\.\*|)(first|last)(\.\*|)$ ]]
                                then
                                    times+=(${BASH_REMATCH//${BASH_REMATCH//.\*/}/$(__um_calculating_date 3 "${BASH_REMATCH//.\*/}")})
                                else
                                    times+=($(date --date="${time//.\*/}" +%s))
                                fi
                            done
                            if ((${#times[@]} == 1))
                            then
                                egrep ${not:+-v} \
                                        -e "^(\"[^\"\|]*\"\|){2}\"${times[0]}\"\|(\"[^\"\|]*\"\|){8}(\"[^\"\|]*\"){1}$" \
                                        "${URIMARK_DATA_DIR}/_index" \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            elif (( ${#times[@]} == 2 ))
                            then
                                times[0]=$(__um_query_binary ${times[0]//.\*/} 1 3)
                                times[1]=$(__um_query_binary ${times[1]//.\*/} 2 3)
                                sort -t '|' -k 3.2n "${URIMARK_DATA_DIR}/_index" | \
                                    sed -r -n \
                                        -e "/^(\"[^\"\|]*\"\|){2}\"${times[0]}\"\|(\"[^\"\|]*\"\|){8}(\"[^\"\|]*\"){1}$/,/^(\"[^\"\|]*\"\|){2}\"${times[1]}\"\|(\"[^\"\|]*\"\|){8}(\"[^\"\|]*\"){1}$/${not:+!}p" \
                                        -e "/^(\"[^\"\|]*\"\|){2}\"${times[1]}\"\|(\"[^\"\|]*\"\|){8}(\"[^\"\|]*\"){1}$/${not:+!}p" \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    md)
                            for time in ${val//;/ }
                            do
                                if [[ $time =~ ^\^ ]]
                                then
                                    time=${time#^}
                                else
                                    time=${time/#/.\*}
                                fi
                                if [[ $time =~ \$$ ]]
                                then
                                    time=${time/%$/}
                                else
                                    time=${time/%/.\*}
                                fi
                                if [[ $time =~ ^(\.\*|)(first|last)(\.\*|)$ ]]
                                then
                                    times+=(${BASH_REMATCH//${BASH_REMATCH//.\*/}/$(__um_calculating_date 4 "${BASH_REMATCH//.\*/}")})
                                else
                                    times+=($(date --date="${time//.\*/}" +%s))
                                fi
                            done
                            if ((${#times[@]} == 1))
                            then
                                egrep ${not:+-v} \
                                        -e "^(\"[^\"\|]*\"\|){3}\"${times[0]}\"\|(\"[^\"\|]*\"\|){7}(\"[^\"\|]*\"){1}$" \
                                        "${URIMARK_DATA_DIR}/_index" \
                                    >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            elif (( ${#times[@]} == 2 ))
                            then
                                times[0]=$(__um_query_binary ${times[0]//.\*/} 1 4)
                                times[1]=$(__um_query_binary ${times[1]//.\*/} 2 4)
                                    sort -t '|' -k 4.2n "${URIMARK_DATA_DIR}/_index" | \
                                        sed -r -n \
                                            -e "/^(\"[^\"\|]*\"\|){3}\"${times[0]}\"\|(\"[^\"\|]*\"\|){7}(\"[^\"\|]*\"){1}$/,/^(\"[^\"\|]*\"\|){3}\"${times[1]}\"\|(\"[^\"\|]*\"\|){7}(\"[^\"\|]*\"){1}$/${not:+!}p" \
                                            -e "/^(\"[^\"\|]*\"\|){3}\"${times[1]}\"\|(\"[^\"\|]*\"\|){7}(\"[^\"\|]*\"){1}$/${not:+!}p" \
                                        >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            fi
                            ;;
                    scheme)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){4}\"${pattern}\"\|(\"[^\"\|]*\"\|){6}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    authority)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){5}\"${pattern}\"\|(\"[^\"\|]*\"\|){5}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    part)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){6}\"${pattern}\"\|(\"[^\"\|]*\"\|){4}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    name)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){7}\"${pattern}\"\|(\"[^\"\|]*\"\|){3}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    description)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){8}\"${pattern}\"\|(\"[^\"\|]*\"\|){2}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    hierarchy)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){9}\"${pattern}\"\|(\"[^\"\|]*\"\|){1}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    tag)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){10}\"(.*${pattern}.*)\"\(\|\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    reference)
                            __um_query_parse_val
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){11}\"(.*${pattern}.*)\"$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                    uri)
                            query_uri_schemes=${val%%:*}
                            IFS='/' read -r query_uri_authority \
                                    query_uri_schemes_specific_parts \
                                <<< "${val##*://}"
                            query_uri_schemes_specific_parts=/${query_uri_schemes_specific_parts}
                            egrep ${not:+-v} \
                                    -e "^(\"[^\"\|]*\"\|){4}\"${query_uri_schemes}\"\|\"${query_uri_authority}\"\|\"${query_uri_schemes_specific_parts}\"\|(\"[^\"\|]*\"\|){4}(\"[^\"\|]*\"){1}$" \
                                    "${URIMARK_DATA_DIR}/_index" \
                                >> "${URIMARK_TMP_DIR}/${operator}${operators[$operator]}"
                            ;;
                esac
                ids=()
                times=()
                not=
            fi
        done
    fi
}

__um_query_binary()
{
    declare \
        b= \
        begin= \
        e= \
        end= \
        middle= \
        pattern=

    declare -a array=()

    pattern=$1
    if (($2 == 1))
    then
        b=1
    else
        e=1
    fi
    mapfile -t array \
        < <(cut -d '|' -f "$3" "${URIMARK_DATA_DIR}/_index" | \
        tr -d '"' | \
        sort -n)
    begin=0
    end=$((${#array[@]} - 1))

    while ((begin <= end))
    do
        middle=$((begin + (end-begin) / 2))
        if ((${array[middle]} >= pattern))
        then
            if ((e && ${array[middle+1]:-${array[middle]}} <= pattern))
            then
                break
            else
                end=$((middle - 1))
            fi
        elif ((${array[middle]} <= pattern))
        then
            if ((b && ${array[middle+1]:-${array[middle]}} >= pattern))
            then
                break
            else
                begin=$((middle + 1))
            fi
        fi
    done

    printf '%s\n' "${array[middle]}"
}

__um_query_post()
{
    if [[ ${operators[and]} -eq 1 ]]
    then
        __um_query_post_and() { sort "${URIMARK_TMP_DIR}/and1" | uniq ; }
    elif [[ ${operators[and]} -gt 1 ]]
    then
        __um_query_post_and()
        {
            diff --unchanged-group-format='%=' \
                    --old-group-format='' --new-group-format='' \
                    --changed-group-format='' --from-file ${URIMARK_TMP_DIR}/and* | \
                sort | \
                uniq
        }
    fi

    if [[ ${operators[or]} && ${operators[and]} ]]
    then
        __um_query_post_or()
        {
            comm -12 <(sort "${URIMARK_TMP_DIR}/or1") <(__um_query_post_and) | \
                sort -t '|' -k 2.2n | \
                uniq
        }
    elif ((${operators[or]}))
    then
        __um_query_post_or() { sort -t '|' -k 2.2n "${URIMARK_TMP_DIR}/or1" | uniq ; }
    fi

    if [[ ${operators[or]} && ${operators[not]} ]]
    then
        __um_query_post_result() { comm -23 <(__um_query_post_or) \
            <(sort -t '|' -k 2.2n  "${URIMARK_TMP_DIR}/not1" | uniq) ; }
    else
        __um_query_post_result() { __um_query_post_or ; }
    fi

    [[ ${hook[${hook_choosen} header]} ]] && eval "${hook[${hook_choosen} header]}"
    eval "${hook[${hook_choosen} preprocess]} __um_query_post_result ${hook[${hook_choosen} postprocess]}"
    [[ ${hook[${hook_choosen} footer]} ]] && eval "${hook[${hook_choosen} footer]}"
}

__um_add()
{
    declare \
        aid= \
        authority= \
        auuid= \
        bd= \
        date= \
        description= \
        hierarchy= \
        i= \
        id= \
        md= \
        name= \
        part= \
        scheme= \
        succeeded= \
        uri= \
        uuid=

    declare -a \
        references=() \
        tags=()

    declare -ga dir_stack=()

    if (($# == 0))
    then
        read -re -p "URI: " uri
        if [[ ! $uri =~ ^(http|https|ftp|ftps|dav|davs|gopher|webdav|webdavs):// ]]
        then
            { echo "Wrong scheme." 1>&2 ; return 1 ; }
        elif [[ $(URIMARK_TMP_DIR=${URIMARK_TMP_DIR}_ ; __um_query uri="${uri}" 2>/dev/null && \
                __um_query_post 2>/dev/null) ]]
        then
            { echo "URI '$uri' has already been recorded." 1>&2 ; return 1 ; }
        fi
        read -re -p "Name: " name
        read -re -p "Description: " description
        IFS=';' read -re -p "Tags: " -a tags
        read -re -p "Hierarchy: " hierarchy
        IFS=';' read -re -p "References: " -a references
    else
        for i
        do
            case $i in
                uri=?*)
                        uri=${i#*=}
                        if [[ ! $uri =~ ^(http|https|ftp|ftps|dav|davs|gopher|webdav|webdavs):// ]]
                        then
                            { echo "Wrong scheme." 1>&2 ; return 1 ; }
                        elif [[ $(URIMARK_TMP_DIR=${URIMARK_TMP_DIR}_ ; __um_query uri="${uri}" 2>/dev/null && \
                                __um_query_post 2>/dev/null) ]]
                        then
                            { echo "URI '$uri' has already been recorded." 1>&2 ; return 1 ; }
                        fi
                        ;;
                name=?*)
                        name=${i#*=}
                        ;;
                description=?*)
                        description=${i#*=}
                        ;;
                hierarchy=?*)
                        hierarchy=${i#*=}
                        ;;
                tag=?*)
                        IFS=';' read -r -a tags <<< "${i#*=}"
                        ;;
                reference=?*)
                        IFS=';' read -r -a references <<< "${i#*=}"
                        ;;
            esac
        done
        [[ ! $uri ]] && { echo "We need an URI to record." 1>&2 ; return 1 ; }
    fi

    date=$(date --date=now +%s)

    ((${#tags[@]} == 0)) && tags[0]=$tag_default
    ((${#references[@]} == 0)) && references[0]=$reference_default

    bd=$date
    md=$date
    id=$(__um_calculating_id next)
    scheme=${uri%%:*}
    IFS='/' read -r authority part <<< "${uri##*://}"
    part=/${part%%/}

    read -r auuid aid < <(hook_choosen=um_default ; __um_query authority=^${authority}$ 2>/dev/null && \
        __um_query_post 2>/dev/null)
    if [[ $auuid && $aid ]]
    then
        uuid=$auuid
        pushd "$uuid" 1>/dev/null
        printf '%s\n' "Authority has already been recorded at file://${URIMARK_DATA_DIR}/${auuid} ." 1>&2
        __um_add_print && succeeded=succeeded
    else
        uuid=$(__um_random 8)
        mkdir -p "${URIMARK_DATA_DIR}/${uuid}" && \
            printf '%s\n' "New authority has been recorded at file://${URIMARK_DATA_DIR}/${uuid} ." 1>&2
        pushd "$uuid" 1>/dev/null
        __um_add_print && succeeded=succeeded
    fi

    if [[ $succeeded ]]
    then
        printf '%s\n' "New URI with id ${id} has been recorded." 1>&2
        dir_stack=($(dirs -l -p))
    else
         { printf '%s\n' "URI has not been recorded." 1>&2 ; return 1 ; }
    fi
}

__um_add_print()
{
    declare \
            j= \
            k=

    exec 3>"${URIMARK_DATA_DIR}/${uuid}/${id}"

    printf '%s\n' "uuid=$uuid
date_build=$bd
date_modification=$md
uri_authority=\"${authority}\"
uri_scheme=\"${scheme}\"
uri_scheme_specific_part=\"${part}\"
uri_scheme_specific_part_description=\"${description:-$description_default}\"
uri_scheme_specific_part_hierarchy=\"${hierarchy:-$hierarchy_default}\"
uri_scheme_specific_part_name=\"${name:-$name_default}\"
uri_scheme_specific_part_id=$id" >&3

    for j in "${!references[@]}"
    do
        printf '%s\n' "uri_scheme_specific_part_reference[$j]=${references[$j]}"
    done 1>&3

    for k in "${!tags[@]}"
    do
        printf '%s\n' "uri_scheme_specific_part_tag[$k]=\"${tags[$k]}\""
    done 1>&3

    exec 3<&-
}

__um_edit()
{
    declare \
        date= \
        date_build= \
        date_modification= \
        eid= \
        euuid= \
        file_tmp= \
        j= \
        k= \
        md5_post= \
        md5_pre= \
        modification= \
        uri_authority= \
        uri_scheme= \
        uri_scheme_specific_part= \
        uri_scheme_specific_part_description= \
        uri_scheme_specific_part_hierarchy= \
        uri_scheme_specific_part_id= \
        uri_scheme_specific_part_name= \
        uuid=

    declare -ga dir_stack=()

    declare -a \
       uri_scheme_specific_part_reference=() \
       uri_scheme_specific_part_tag=()

    if (($# == 0))
    then
        { echo "No arguments has been specified." 1>&2 ; return 1 ; }
    else
        while read -r euuid eid
        do
            file_tmp=${URIMARK_TMP_DIR}/urimark.${RANDOM}
            cp -- "${URIMARK_DATA_DIR}/${euuid}/${eid}" "$file_tmp"
            pushd "$euuid" >/dev/null
            md5_pre=$(md5sum "$file_tmp")
            $editor "$file_tmp" </dev/tty
            date=$(date --date=now +%s)
            md5_post=$(md5sum "$file_tmp")
            if [[ $md5_pre != $md5_post ]]
            then
                (
                    source "$file_tmp"
                    date_modification=$date
                    {
                        printf '%s\n' "uuid=$uuid
date_build=$date_build
date_modification=$date_modification
uri_authority=\"${uri_authority}\"
uri_scheme=\"${uri_scheme}\"
uri_scheme_specific_part=\"${uri_scheme_specific_part}\"
uri_scheme_specific_part_description=\"${uri_scheme_specific_part_description}\"
uri_scheme_specific_part_hierarchy=\"${uri_scheme_specific_part_hierarchy}\"
uri_scheme_specific_part_name=\"${uri_scheme_specific_part_name}\"
uri_scheme_specific_part_id=$uri_scheme_specific_part_id"
                        for j in "${!uri_scheme_specific_part_reference[@]}"
                        do
                            printf '%s\n' "uri_scheme_specific_part_reference[$j]=${uri_scheme_specific_part_reference[$j]}"
                        done
                        for k in "${!uri_scheme_specific_part_tag[@]}"
                        do
                            printf '%s\n' "uri_scheme_specific_part_tag[$k]=\"${uri_scheme_specific_part_tag[$k]}\""
                        done
                    } > "${URIMARK_DATA_DIR}/${euuid}/${eid}"
                    printf '%s\n' "Data set with id ${eid} has been modified." 1>&2
                )
                modification=modification
            else
                printf '%s\n' "Data set with id ${eid} has not been modified." 1>&2
            fi
        done < <(hook_choosen=um_default ; __um_query "$@" && __um_query_post)
        [[ $modification == modification ]] &&
        {
            dir_stack=($(dirs -l -p))
            __um_rebuild_index
        }
    fi
}

__um_delete()
{
    declare \
        d= \
        delete_all= \
        response=

    declare -a deletion=()

    declare -ga dir_stack=()

    if (($# == 0))
    then
        { echo "We need to specify a filter." 1>&2 ; return 1 ; }
    else
        while read -r
        do
            if [[ $delete_all == delete_all || $non_interactive == non_interactive ]]
            then
                deletion+=("$REPLY")
            else
                printf 'UUID: %s\nID:   %s\n' $REPLY
                read -u 3 -p "Do you really wanne delete this record? (y/n/all/quit) " response
                case $response in
                    all)    delete_all=delete_all   ;&
                    y|yes)  deletion+=("$REPLY")    ;;
                    quit)   deletion=() ; break    ;;
                    *)      continue               ;;
                esac
            fi
        done 3<&0 < <(hook_choosen=um_default ; __um_query "$@" && __um_query_post)
        if ((${#deletion[@]} != 0))
        then
            for d in "${deletion[@]}"
            do
                pushd "${d% *}" >/dev/null
                rm -- "${URIMARK_DATA_DIR}/${d% *}/${d#* }"
            done
            dir_stack=($(dirs -l -p))
            { echo "Records have been deleted." 1>&2 ; return 0 ; }
        else
            { echo "No Record has been deleted." 1>&2 ; return 1 ; }
        fi
    fi
}

__um_modify()
{
    declare \
        date= \
        i= \
        j= \
        k= \
        modify_all= \
        record= \
        ref= \
        response= \
        tag=

    declare -a \
       modification=() \
       references=() \
       tags=()

    declare -ga dir_stack=()

    if ((${#mods[@]} == 0))
    then
         { echo "We need to specify a modification pattern." 1>&2 ; return 1 ; }
    else
        for i in "${!mods[@]}"
        do
            case ${mods[i]} in
                authority=?*)
                        mods[i]="-e s|^uri_authority=.*$|uri_authority=\"${mods[i]#*=}\"|"
                        ;;
                scheme=?*)
                        mods[i]="-e s|^uri_scheme=.*$|uri_scheme=\"${mods[i]#*=}\"|"
                        ;;
                part=?*)
                        mods[i]="-e s|^uri_scheme_specific_part=.*$|uri_scheme_specific_part=\"${mods[i]#*=}\"|"
                        ;;
                name=?*)
                        mods[i]="-e s|^uri_scheme_specific_part_name=.*$|uri_scheme_specific_part_name=\"${mods[i]#*=}\"|"
                        ;;
                description=?*)
                        mods[i]="-e s|^uri_scheme_specific_part_description=.*$|uri_scheme_specific_part_description=\"${mods[i]#*=}\"|"
                        ;;
                hierarchy=?*)
                        mods[i]="-e s|^uri_scheme_specific_part_hierarchy=.*$|uri_scheme_specific_part_hierarchy=\"${mods[i]#*=}\"|"
                        ;;
                tag=?*)
                        for j in "${patterns[@]}"
                        do
                            [[ $j == tag=?* ]] && tags+=("${j#*=}")
                        done
                        printf -v tag '%s|' "${tags[@]//^/}"
                        tag=${tag//$/}
                        mods[i]="-e s|^(uri_scheme_specific_part_tag\[.*\]=)\"(${tag%|*})\"$|\1\"${mods[i]#*=}\"|"
                        ;;
                tag-=?*)
                        mods[i]="-e /^uri_scheme_specific_part_tag\[.*\]=\"${mods[i]#*=}\"$/d"
                        ;;
                tag+=?*)
                        index=$(__um_random 4)
                        mods[i]="-e $ i uri_scheme_specific_part_tag[${index}]=\"${mods[i]#*=}\""
                        ;;
                reference=?*)
                        for k in "${patterns[@]}"
                        do
                            [[ $k == reference=?* ]] && references+=("${k#*=}")
                        done
                        printf -v ref '%s|' "${references[@]//^/}"
                        ref=${ref//$/}
                        mods[i]="-e s|^(uri_scheme_specific_part_reference\[.*\]=)(${ref%|*})$|\1${mods[i]#*=}|"
                        ;;
                reference-=?*)
                        mods[i]="-e /^uri_scheme_specific_part_reference\[.*\]=${mods[i]#*=}$/d"
                        ;;
                reference+=?*)
                        index=$(__um_random 4)
                        mods[i]="-e $ i uri_scheme_specific_part_reference[${index}]=${mods[i]#*=}"
                        ;;
                *)
                        unset -v "mods[i]"
                        ;;
            esac
        done

        while read -r
        do
            if [[ $modify_all == modify_all  || $non_interactive == non_interactive ]]
            then
                modification+=("${URIMARK_DATA_DIR}/${REPLY% *}/${REPLY#* }")
                pushd "${REPLY% *}" >/dev/null
            else
                printf 'UUID: %s\nID:   %s\n' $REPLY
                read -u 3 -p "Do you really wanne modify this record? (y/n/all/quit) " response
                case $response in
                    all)
                            modify_all=modify_all
                            ;&
                    y|yes)
                            modification+=("${URIMARK_DATA_DIR}/${REPLY% *}/${REPLY#* }")
                            pushd "${REPLY% *}" >/dev/null
                            ;;
                    quit)
                            modification=()
                            break
                            ;;
                    *)
                            continue
                            ;;
                esac
            fi
        done 3<&0 < <(hook_choosen=um_default ; __um_query "${patterns[@]}" && __um_query_post)
        if ((${#modification[@]} != 0))
        then
            dir_stack=($(dirs -l -p))
            date=$(date --date=now +%s)
            printf '%s\n' "${modification[@]}" | \
                xargs -r sed -r -i \
                    -e "/date_modification=.*/ c date_modification=${date}" "${mods[@]}"
            { echo "Records have been modified." 1>&2 ; return 0 ; }
        else
            { echo "No Record has been modified." 1>&2 ; return 1 ; }
        fi
    fi
}

__um_rebuild()
{
    declare \
        rebuild_all= \
        response=

    declare -ga dir_stack=()

    if (($# == 0))
    then
        { echo "We need to specify a filter." 1>&2 ; return 1 ; }
    else
        while read -r
        do
            if [[ $rebuild_all == rebuild_all || $non_interactive == non_interactive ]]
            then
                pushd "$REPLY" >/dev/null
            else
                printf 'UUID: %s\n' $REPLY
                read -u 3 -p "Do you really wanne rebuild all records with this uuid? (y/n/all/quit) " response
                case $response in
                    all)    rebuild_all=rebuild_all     ;&
                    y|yes)  pushd "$REPLY" >/dev/null   ;;
                    quit)   DIRSTACK=(); break          ;;
                    *)      continue                    ;;
                esac
            fi
        done 3<&0 < <(hook_choosen=um_default ; __um_query "$@" && __um_query_post | cut -d ' ' -f 1 | sort | uniq)
        if ((${#DIRSTACK[@]} > 1 ))
        then
            dir_stack=($(dirs -l -p))
            return 0
        else
            { echo "No index has been rebuild." 1>&2 ; return 1 ; }
        fi
    fi
}

__um_rebuild_index()
{
    declare \
        dir= \
        i=

    echo "Index is beeing rebuild..." 1>&2

    while read -r dir
    do
        declare -a \
           r_au=() \
           r_db=() \
           r_desc=() \
           r_dm=() \
           r_hier=() \
           r_id=() \
           r_name=() \
           r_part=() \
           r_ref=() \
           r_scheme=() \
           r_tag=() \
           r_uuid=() \
           uri_scheme_specific_part_reference=() \
           uri_scheme_specific_part_tag=()
        declare \
            date_build= \
            date_modification= \
            uri_authority= \
            uri_scheme= \
            uri_scheme_specific_part= \
            uri_scheme_specific_part_description= \
            uri_scheme_specific_part_hierarchy= \
            uri_scheme_specific_part_id= \
            uri_scheme_specific_part_name= \
            uuid=
        > "${dir}/_index"
        while read -r
        do
            source "$REPLY" 2>/dev/null &&
            {
                r_uuid+=($uuid)
                r_db+=($date_build)
                r_dm+=($date_modification)
                r_au+=("$uri_authority")
                r_id+=($uri_scheme_specific_part_id)
                r_scheme+=("$uri_scheme")
                r_part+=("$uri_scheme_specific_part")
                r_desc+=("$uri_scheme_specific_part_description")
                r_name+=("$uri_scheme_specific_part_name")
                r_hier+=("$uri_scheme_specific_part_hierarchy")
                r_ref+=("$(printf '%s;' "${uri_scheme_specific_part_reference[@]}")")
                r_tag+=("$(printf '%s;' "${uri_scheme_specific_part_tag[@]}")")
            }
            uri_scheme_specific_part_reference=()
            uri_scheme_specific_part_tag=()
        done < <(find -H "$dir" -mindepth 1 -maxdepth 1 -type f ! -name _index -print)
        exec 3>"${dir}/_index"
        for i in "${!r_uuid[@]}"
        do
            printf "%s\n" "\"${r_uuid[i]}\"|\"${r_id[i]}\"|\"${r_db[i]}\"|\"${r_dm[i]}\"|\"${r_scheme[i]}\"|\"${r_au[i]}\"|\"${r_part[i]}\"|\"${r_name[i]}\"|\"${r_desc[i]}\"|\"${r_hier[i]}\"|\"${r_tag[i]%;}\"|\"${r_ref[i]%;}\"" >&3
        done
        exec 3<&-
    done < <(printf '%s\n' "${dir_stack[@]}" | grep -e "${URIMARK_DATA_DIR}/.*" | sort | uniq)

    if (($? == 0))
    then
        { echo "Done." 1>&2 ; return 0 ; }
    else
        { echo "Undone." 1>&2 ; return 1 ; }
    fi
}

__um_cat_indexes() { find -H "$URIMARK_DATA_DIR" -mindepth 2 -type f -name _index -print | \
    xargs -r cat > "${URIMARK_DATA_DIR}/_index" ; }

__um_random()
{
    declare random=$(od -vAn -N "$1" -tu </dev/urandom)

    printf '%s\n' "${random// /}"
}

__um_calculating_id()
{
    __um_calculating_id_print()
    {
        cut -d '|' -f2 "${URIMARK_DATA_DIR}/_index" | \
            tr -d '\"' | \
            sort -n
    }

    if [[ $1 == first ]]
    then
        __um_calculating_id_print | head -n1
    elif [[ $1 == last ]]
    then
        __um_calculating_id_print | tail -n1
    elif [[ $1 == next ]]
    then
        if [[ ! -e ${URIMARK_DATA_DIR}/_index ]]
        then
            echo 1
        else
            comm --nocheck-order -23 \
                <(eval "printf '%s\n' {1..$(($(__um_calculating_id_print | tail -n1) + 1))}") \
                <(__um_calculating_id_print) | \
                head -n1
        fi
    fi
}

__um_calculating_date()
{
    __um_calculating_date_print()
    {
        cut -d '|' -f $1 "${URIMARK_DATA_DIR}/_index" | \
            tr -d '"' | \
            sort -n
    }

    if [[ $2 == first ]]
    then
        __um_calculating_date_print "$1" | head -n1
    elif [[ $2 == last ]]
    then
        __um_calculating_date_print "$1" | tail -n1
    fi
}

__um_delete_empty_dirs() { find -H "$URIMARK_DATA_DIR" -maxdepth 1 -type d -empty -delete ; }

__um_check_args()
{
    declare o=
    if [[ ! $OPTARG =~ ^-.+ ]]
    then
        for o
        do
            patterns+=("$o")
        done
    else
        { printf '%s\n' "Option '-${opt}' requires an argument." 1>&2 ; exit 1 ; }
    fi
}

# -- MAIN.

declare -r \
    predir_confile=${XDG_CONFIG_HOME:-${HOME}/.config} \
    predir_datadir=${XDG_DATA_HOME:-${HOME}/.local/share}
declare -r \
    URIMARK_CONF_FILE=${URIMARK_CONF_FILE:-${predir_confile}/urimark/urimark.conf} \
    URIMARK_DATA_DIR=${URIMARK_DATA_DIR:-${predir_datadir}/urimark/data}
declare -r CDPATH=$URIMARK_DATA_DIR
declare URIMARK_TMP_DIR=${URIMARK_TMP_DIR:-"${TMPDIR:-/tmp}/urimark"}

trap "{ rm -fr -- "$URIMARK_TMP_DIR" "${URIMARK_TMP_DIR}_" ; exit 0 ; }" EXIT

[[ ! -e ${URIMARK_CONF_FILE%/*} ]] && mkdir -p -- "${URIMARK_CONF_FILE%/*}"
[[ ! -e $URIMARK_DATA_DIR ]] && mkdir -p -- "$URIMARK_DATA_DIR"
mkdir -p -- "$URIMARK_TMP_DIR" "${URIMARK_TMP_DIR}_"

declare \
    arg= \
    args= \
    delim=\'

for arg
do
    arg=${arg#--}
    case $arg in
        add)                args="${args}-A "                            ;;
        and)                args="${args}-a "                            ;;
        authority=?*)       args="${args}-Y ${arg#*=} "                  ;;
        bd=?*)              args="${args}-B ${arg#*=} "                  ;;
        delete)             args="${args}-d "                            ;;
        description=?*)     args="${args}-8 ${delim}${arg#*=}${delim} "  ;;
        edit)               args="${args}-e "                            ;;
        help)               args="${args}-h "                            ;;
        hierarchy=?*)       args="${args}-H ${arg#*=} "                  ;;
        id=?*)              args="${args}-I ${arg#*=} "                  ;;
        md=?*)              args="${args}-M ${arg#*=} "                  ;;
        mod)                args="${args}-9 "                            ;;
        modify)             args="${args}-m "                            ;;
        name=?*)            args="${args}-N ${delim}${arg#*=}${delim} "  ;;
        non-interactive)    args="${args}-n "                            ;;
        not)                args="${args}-! "                            ;;
        or)                 args="${args}-o "                            ;;
        part=?*)            args="${args}-T ${delim}${arg#*=}${delim} "  ;;
        print-uri)          args="${args}-u "                            ;;
        rebuild)            args="${args}-r "                            ;;
        reference=?*)       args="${args}-5 ${delim}${arg#*=}${delim} "  ;;
        reference+=?*)      args="${args}-6 ${delim}${arg#*+=}${delim} " ;;
        reference-=?*)      args="${args}-7 ${delim}${arg#*-=}${delim} " ;;
        scheme=?*)          args="${args}-S ${arg#*=} "                  ;;
        tag=?*)             args="${args}-2 ${delim}${arg#*=}${delim} "  ;;
        tag+=?*)            args="${args}-3 ${delim}${arg#*+=}${delim} " ;;
        tag-=?*)            args="${args}-4 ${delim}${arg#*-=}${delim} " ;;
        uri=?*)             args="${args}-1 ${delim}${arg#*=}${delim} "  ;;
        uuid=?*)            args="${args}-0 ${arg#*=} "                  ;;
        version)            args="${args}-v "                            ;;
        authority=|\
        bd=|\
        cloud=|\
        description=|\
        hierarchy=|\
        id=|\
        md=|\
        name=|\
        part=|\
        reference=|\
        reference-=|\
        reference+=|\
        scheme=|\
        tag=|\
        tag-=|\
        tag+=|\
        uri=|\
        uuid=)
                            printf '%s\n' "Flag '${arg}' requires an argument." 1>&2
                            exit 1                                       ;;
        *)                  if [[ ${arg:0:1} == - ]]
                            then
                                args="${args}${arg} "
                            else
                                args="${args}${delim}${arg}${delim} "
                            fi
    esac
done

declare \
    action= \
    i= \
    mod= \
    non_interactive= \
    opt= \
    OPTIND=1

declare -a \
    mods=() \
    patterns=()

eval set -- "$args"
while getopts :0:1:2:3:4:5:6:7:8:9AaB:deH:hI:M:mN:no!rS:T:vY: opt
do
    case $opt in
        0)  __um_check_args "uuid=$OPTARG"          ;;
        1)  __um_check_args "uri=$OPTARG"           ;;
        2)  __um_check_args "tag=$OPTARG"           ;;
        3)  __um_check_args "tag+=$OPTARG"          ;;
        4)  __um_check_args "tag-=$OPTARG"          ;;
        5)  __um_check_args "reference=$OPTARG"     ;;
        6)  __um_check_args "reference+=$OPTARG"    ;;
        7)  __um_check_args "reference-=$OPTARG"    ;;
        8)  __um_check_args "description=$OPTARG"   ;;
        9)  patterns+=(mod)                         ;;
        A)  action=add                              ;;
        a)  patterns+=(and)                         ;;
        B)  __um_check_args "bd=$OPTARG"            ;;
        d)  action=delete                           ;;
        e)  action=edit                             ;;
        h)  action=help                             ;;
        H)  __um_check_args "hierarchy=$OPTARG"     ;;
        I)  __um_check_args "id=$OPTARG"            ;;
        m)  action=modify                           ;;
        M)  __um_check_args "md=$OPTARG"            ;;
        n)  non_interactive=non_interactive         ;;
        N)  __um_check_args "name=$OPTARG"          ;;
        o)  patterns+=(or)                          ;;
        !)  patterns+=(not)                         ;;
        r)  action=rebuild                          ;;
        S)  __um_check_args "scheme=$OPTARG"        ;;
        T)  __um_check_args "part=$OPTARG"          ;;
        v)  action=version                          ;;
        Y)  __um_check_args "authority=$OPTARG"     ;;
        :)  printf '%s\n' "Option '-${OPTARG}' requires an argument." 1>&2
            exit 1                                  ;;
        \?) printf '%s\n' "Unknown flag: '-${OPTARG}'." 1>&2
            exit 1
    esac
done

declare \
    description_default= \
    editor= \
    hierarchy_default= \
    hook_default= \
    name_default= \
    reference_default= \
    tag_defaul=

declare -A hook

[[ -f $URIMARK_CONF_FILE ]] && source "$URIMARK_CONF_FILE"

editor=${editor:-$EDITOR}
[[ ! ${hook[${hook_default} description]} ]] && hook_default=um_default
tag_default=${tag_default:-null}
reference_default=${reference_default:-null}
description_default=${description_default:-null}
hierarchy_default=${hierarchy_default:-null}
name_default=${name_default:-null}

hook[um_default description]="Builtin default report"
hook[um_default postprocess]="| cut -d '|' -f1,2 | tr -d '\"' | tr '|' ' '"

declare hook_choosen=

while (($# > 0))
do
    case $1 in
        -9|-A|-a|-d|-e|-h|-m|-n|-o|-!|-r|-v)
            shift 1
            ;;
        -[0-8]|-B|-H|-I|-M|-N|-S|-T|-Y)
            shift 2
            ;;
        *)
            if [[ ${hook[${1} description]} ]]
            then
                hook_choosen=$1
                shift 1
            else
                { printf '%s\n' "Unknown parameter: '${1}'." 1>&2 ; exit 1 ; }
            fi
    esac
done

hook_choosen=${hook_choosen:-$hook_default}
[[ ${hook[${hook_choosen} filter]} && ${#patterns[@]} -eq 0 ]] && \
    patterns=(${hook[${hook_choosen} filter]})

case $action in
    add)
            __um_add "${patterns[@]}" &&
            {
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    delete)
            __um_delete "${patterns[@]}" &&
            {
                __um_delete_empty_dirs
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    edit)
            __um_edit "${patterns[@]}"
            ;;
    help)
            __um_help
            ;;
    modify)
            for i in "${!patterns[@]}"
            do
                [[ ${patterns[$i]} == mod ]] && \
                    mod=mod && \
                    unset -v "patterns[$i]" && \
                    continue
                [[ $mod == mod ]] && \
                    mods+=("${patterns[$i]}") && \
                    unset -v "patterns[$i]"
            done
            __um_modify &&
            {
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    rebuild)
            __um_rebuild "${patterns[@]}" &&
            {
                __um_rebuild_index
                __um_cat_indexes
            }
            ;;
    version)
            __um_version
            ;;
    *)
            if [[ ! $action ]]
            then
                action=query
                __um_query "${patterns[@]}" && __um_query_post
            else
                { echo "No subcommand has been specified." 1>&2 ; exit 1 ; }
            fi
esac
